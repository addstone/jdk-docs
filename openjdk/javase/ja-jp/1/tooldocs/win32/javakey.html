<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<title>javakey- Java セキュリティツール</TITLE>
</head>
<body>

<H1>javakey - Java セキュリティツール</H1>
<blockquote>
エンティティ (人、会社など) のデータベース、公開鍵と秘密鍵、および認定書を管理します。また、アーカイブファイルの署名を生成し証明します。
</blockquote>

<h2>機能説明</h2>
<blockquote>
<pre>
<strong>javakey</strong> [ <a href="javakey.html#Options">options</a> ]
</pre>
</blockquote>

<h2>説明</h2>

<blockquote>

<b>javakey</b> は、SUN 社のセキュリティプロバイダコマンド行ツールです。このツールの第一の目的は、アーカイブファイルのデジタル署名を生成することです。署名は、ファイルが指定のエンティティ ("<i>signer</i>") から転送されてきたものであることを証明します。特定ファイルの署名を生成するには、署名者は、まずそのファイルの公開鍵と秘密鍵のペアを持つ必要があります。また、その公開鍵を認証する認定書が 1 つ以上必要です。したがって、 
<b>javakey</b> は、各エンティティが「信頼できる」かどうかを示すだけでなく、エンティティ、鍵および認定書の永続的なデータベースを構築し管理します。


<h3>アイデンティティ、署名者、鍵</h3>

<blockquote>

<p><b>javakey</b>が管理するエンティティには、 <i>identities</i> と <i>signers</i> の 2 つのタイプがあります。 

<p><i>アイデンティティ</i>は、公開鍵と現実世界のエンティティ (人、会社または組織など) を関連付けるものです。またアイデンティティは、公開鍵を認証する 1 つ以上の認定書と関連している可能性があります。認定書は、1 つのエンティティからのデジタル署名された文書です。それには、あるエンティティの公開鍵には特別な値があることが書かれています(<a href = "#Certificates">認定書</a>を参照してください)。

<p><i>署名者</i> は公開鍵の他に、対応する秘密鍵をもつエンティティです。秘密鍵は署名に使う公開鍵とは異なります。ファイルに署名する前に、署名者は公開鍵とそれと関連する秘密鍵を、ペアでもつ必要があります。公開鍵を認証する認定書も少なくとも 1 つは必要です。

<p><b>javakey</b> では、既存の鍵をインポートしたり、アイデンティティや署名者と関連する新しい鍵を作ることもできます。同様に、認定書も既存のものをインポートしたり、新しく作成することができます。


<h4>アイデンティティと署名者のためのデータベースのユーザ名</h4>

<p>すべてのエンティティ (アイデンティティと署名者) には、<b>javakey</b> によって管理されるデータベースに対してローカルな <i>username</i> があります。ユーザ名は、<b>-c</b> (アイデンティティ作成) オプションや 
<b>-cs</b> (署名者作成) オプションを使用して、データベースへエンティティを追加するときに指定されます。後の <b>javakey</b> コマンドは、エンティティを参照するのにこれと同じユーザ名を使わなければなりません。たとえば、信頼すべき署名者が作成され、ユーザ名として <tt>duke</tt> を代入すると仮定します。そのときのコマンドは、次のとおりです。 

<pre>
    javakey -cs duke true
</pre>

次に、鍵のサイズに 512 ビットを使用して、署名者用の DSA 公開/秘密鍵のペアを生成するには、次のコマンドを使用します。

<pre>
    javakey -gk duke DSA 512
</pre>

<h4>アイデンティティと署名者に関連する信頼</h4>

<p> JDK 1.1 では、クライアント (たとえば、エンドユーザまたはシステム管理者) は <b>javakey</b> を使用して、ある信頼されるエンティティを宣言することができます。 

<p> appletviewer は、信頼されるエンティティによって (<b>javakey</b> を使用して) 署名された JAR ファイルの中でダウンロードされた場合に、任意のアプレットがローカルなアプリケーションとまったく同じ権限で実行されることを可能にします。すなわち、そうしたアプレットは、元の Java セキュリティモデルの「サンドボックス」制約に拘束されません (細かくいえば、<b>javakey</b> が管理するデータベースは、署名が認証できるように、JAR ファイルに署名したエンティティの公開鍵の認定書のコピーも持たなければならない点があります)。今後のリリースでは、許される限り信頼性レベルのより確かなものを提供していきます。


<b>javakey</b> により管理されるデータベースはエンティティの username、
<a href = "#Certificates">認定書</a>、および各エンティティの信頼レベルを保存します。データベースへエンティティを追加するとき、信頼されるまたは信頼されない (デフォルト設定) エンティティであることをその時点で宣言できます。

<pre>
    javakey -cs duke true

    javakey -cs bob false

    javakey -cs morty 
</pre>

最初の例は、<code>duke</code> と名付けた署名者を信頼されるエンティティとして作成しています。次の 2 つの例は、署名者 <code>bob</code> と <code>morty</code> を信頼されないエンティティとして作成しています。信頼のレベルを指定しない場合、デフォルトにより、エンティティは信頼されません。 

<p>後で、前に信頼されなかったエンティティを信頼されるエンティティと宣言することができます。 

<pre>
    javakey -t morty true
</pre>

同様に、前に信頼されたエンティティを信頼されないエンティティと宣言することもできます。 

<pre>
    javakey -t duke false
</pre>

エンティティデータベースの全体の状態を見るには、

<pre>
    javakey -ld
</pre>

を使用してください。

データベースの中の 1 つのエンティティ (この場合、<code>morty</code>) の状態を見るには、

<pre>
    javakey -li morty
</pre>

を使用してください。

</blockquote>

<h3>データベースの位置</h3>

<blockquote>

javakey が管理するデータベースは、デフォルト設定では、<i>identitydb.obj</i> という名前のファイルに格納されています。

データベースは秘密鍵を含む場合があるので、安全な場所に保管する必要があります。デフォルト設定では、データーベースは、JDK インストール ディレクトリに格納されています。別の位置が望ましい場合は <tt>java.security</tt> と呼ばれるセキュリティ マスタプロパティファイルの中の <code>identity.database</code> の値を設定することにより、指定することができます。そのファイルは JDK セキュリティプロパティディレクトリの <code><i>java.home</i>/lib/security</code> に常駐します。ここで、<i>java.home</i> は、JDK インストールされたディレクトリです。

<p>たとえば、位置を指定するには、次のようにします。

<pre>
	identity.database=C:\a\safe\directory\identitydb.obj 
</pre>

</blockquote>



<h3><a name=Certificates>認定書</a></h3>

<blockquote>

<p><b>javakey</b> は、認定書のインポート、作成、表示および保存を行います。認定書は 1 つのエンティティ (署名者) からのデジタル署名された文書です。それには、あるエンティティの公開鍵には特別な値があることが書かれています。認定書に署名したエンティティを信頼する場合、認定書で、指定の公開鍵と他の特定のエンティティの間の関係は本物であると信頼します。

<b>javakey</b> は現在、X.509 の認定書を処理します。このセクションの後半の例は、X.509 の認定書に関連しています。


<h4><a name=CertificateGeneration>認定書の生成</a></h4>

<p>認定書を生成するために、ユーザが情報を提供するファイルを最初に作成します。 

<ul>

<li>発行者 (認定書に署名する署名者) に関する情報 
<li>主体 (認定書で認証された公開鍵のエンティティ) に関する情報
<li>認定書そのもの、その他に関する情報
<li>使用する署名アルゴリズム名 (DSA を使用したくない場合)
<li>認定書のコピーを格納するファイル名

</ul>

<code><a href = "#gcOption">-gc</a></code> オプションを使用して、認定書を生成します。また、ファイルの指定は、次のとおりです。

<pre>
    javakey -gc dukeCertDirFile
</pre>


<p><b>javakey</b> は、提供された情報により、ディレクティブファイルに認定書を作成します。また、その鍵を証明するエンティティの公開鍵や発行者の秘密鍵 (認定書に署名するために必要) など、データベースに格納された情報を使用します。

<p>認定書ディレクティブファイルの例を次に示し、引数の説明をします。

<pre>
#
# Information about the issuer (required).
#
issuer.name=jsmith

#
# The certificate to use for the signing (required if this is not self-signed).
#
issuer.cert=1

#
# Information about the subject (required).
#
subject.name=mlaunay
subject.real.name=Marie Launay
subject.org.unit=JavaSoft
subject.org=Sun MicroSystems
subject.country=Switzerland

#
# Information about the certificate (required).
#
start.date=1 Jan 1997
end.date=15 Jan 1997
serial.number=1001

#
# Signature algorithm to be used (only required if you don't want DSA used).
#
signature.algorithm=MD5/RSA

#
# Name of the file to which to save a copy of the certificate (optional).
#
out.file=cert.cer

</pre>

<p>認定書のディレクティブファイル引数は、別途指定がない限り、すべてに必要です。

<dl>

<dt><tt>issuer.name</tt> と <tt>subject.name</tt> 

<dd>データベースのユーザ名。<code>issuer.name</code> は認定書に署名し、発行する署名者の名前です。<code>subject.name</code> は、その鍵が認定書の発行により、認証されるエンティティ (アイデンティティまたは署名者) の名前です。

<dt><tt>issuer.cert</tt> 

<dd>発行者の認定書のうち、どれを認定ファイルの署名のために使うかを指定し、それにより主体の公開鍵を認証します。その値は、認定書が生成されたとき (またはインポートされたとき)、<b>javakey</b>が発行者の認定書に、以前に代入した番号でなければなりません。javakey が認定書に代入した番号を、 <code><a href = "#ldOption">-ld</a></code> オプションまたは <code><a href = "#liOption">-li</a></code> <b>javakey</b> オプションの出力表示により、調べることができます。注意:  この <i>issuer.cert</i> プロパティは、生成された認定書が自己署名で<i>ない</i>場合のみ、要求されます(自己署名認定書は<i>issuer.name</i> と<i>subject.name</i>が同じ場合の認定書)。

<dt><tt>subject.real.name, subject.org.unit, subject.org, and 
subject.country</tt>

<dd>X.500 の識別名コンポーネント。このようなコンポーネントは、主体の一般的名前、組織単位および国をそれぞれ参照します。

<dt><tt>start.date</tt> と <tt>end.date</tt>

<dd>このような文字列で、認定書の有効開始日と満期 (時刻はオプション) を指定します。認定書は開始日付の時刻から終了日付の時刻まで有効です。開始および終了文字列は、String 引数をとる <code>java.util.Date</code> メソッドが認可する文字列であれば可能です。日付に指定時刻がない場合は、指定日の開始時刻と解釈されます。

<dt><tt>serial.number</tt>

<dd>シリアルナンバー。特定の発行者にとって、この数字はこの発行者が署名した認定書とその他の認定書を区別するため、一意的のものでなければなりません。

<dt><tt>signature.algorithm</tt>

<dd>認定書の署名に使用される署名アルゴリズムの名前。 この引数はオプションです。<code>signature.algorithm</code> の指定がない場合には、 DSA (デジタル署名アルゴリズム) が使用されます。その場合には、署名者の秘密鍵と公開鍵は DSA アルゴリズムに対応するものでなければなりません。非 DSA アルゴリズムは、(1) 指定の名前が<a href="../../guide/security/CryptoSpec.html#AppA">標準アルゴリズム名</a>である場合、 (2) 静的にインストールされている<a href="../../guide/security/CryptoSpec.html#Provider">プロバイダ</a>が、そのアルゴリズムに対して実装を供給する場合、および (3) 署名者の鍵が指定のアルゴリズムに適切である場合に限り使用することができます。たとえば、<code>signature.algorithm</code> プロパティの値が、<code>MD5/RSA</code> または <code>SHA-1/RSA</code> である場合には、署名者の鍵は RSA 鍵でなければなりません。


<dt><tt>out.file</tt>

<dd>認定書を保存するファイル名。この引数はオプションです。

</dl>


<h4><a name=DisplayCertificate>認定書とファイル</a></h4>

<p><b>javakey</b> を使用して、ファイルとして格納された認定書の表示、インポートおよびエクスポートが可能です。

ファイルに格納された認定書を表示するには、<b>-dc</b> オプションを使用します。たとえば、次のとおりです。

<pre>
    javakey -dc certfile.cer
</pre>

<p>これは、 <i>certfile.cer</i> ファイルに格納された認定書に関する情報を表示します。たとえば、次のとおりです。 

<ul>
<li>認定書の型 (現行、X.509v1)
<li>主体に関する情報
<li>公開鍵に関する情報
    <ul>
    <li>アルゴリズムとそのパラメータ (現行、DSA とその p、q、g パラメータの値)
    <li>解析されない鍵のビット
    </ul>
<li>認定書の有効日付
<li>発行者に関する情報
<li>使用する署名アルゴリズムの情報
<li>認定書のシリアルナンバー (16進数)
</ul>

ファイルから認定書をインポートするには、<b>-ic</b> オプションを使用して次のようにします。

<pre>
    javakey -ic joe jcertfile.cer
</pre>

このサンプルコマンドは、ファイル <i>jcertfile.cer</i> に認定書をインポートして、<i>joe</i> と関連付けます。

<p>ファイルから認定書をエクスポートするには、<b>-ec</b> オプションを使用して次のようにします。

<pre>
    javakey -ec jane 2 janecertfile.cer
</pre>

このサンプルコマンドは、jane の認定書 #2 をファイル <i>janecertfile.cer</i> にエクスポートします。認定書の数字は、認定書が生成されたとき (またはインポートされたとき)、 <b>javakey</b> が以前に代入した数字でなければなりません。javakeyが認定書に代入した数字を、 <code><a href = "#ldOption">-ld</a></code> または <code><a href = "#liOption">-li</a></code> <b>javakey</b> オプションの出力表示により、調べることができます。

</blockquote>



<h3><a name=JARSigning> JAR ファイルとデジタル署名</a></h3>

<blockquote>

<p>Java Archive ファイル (JAR ファイル) は JDK1.1 の新しい機能です。この機能は、転送を速く、容易にするために、クラスファイル、イメージ、サウンドおよびその他のデジタルデータを 1 つのファイルにパッケージすることを可能にします。JDK1.1 には、プログラム開発者が JAR ファイルを作成できるように、<a href="jar.html"><tt>jar</tt></a> というツールが入っています。

<p><b>javakey</b> は、JAR ファイルに署名し、証明するために使用します(注意:  証明はまだ実装されていません)。 Java のライセンスを受ける人は、<b>javakey</b> を使用して署名を生成することを重要視することを前提としています。

<p>この時点で、<b>javakey</b> は、 DSA (デジタル署名アルゴリズム) を使用するか、場合によっては MD5/RSA アルゴリズムを使用するかして JAR ファイルに署名することができます。すなわち、署名者の公開鍵と秘密鍵が DSA 鍵である場合には、<b>javakey</b> が、 DSA を使用して JAR ファイルに署名します。署名者の鍵が RSA 鍵である場合には、 <b>javakey</b> は、MD/RSA アルゴリズムを使用して JAR ファイルに署名しようとします。これは、静的にインストールされている <a href="../../guide/security/CryptoSpec.html#Provider">プロバイダ</a>が存在して、 MD5/RSA アルゴリズムの実装を供給する場合に限り可能です。

<p> DSA と MD5/RSA アルゴリズムの両方に対して、ファイルに署名したい場合には、誰でも公開鍵と秘密鍵の両方を持つ必要があります。秘密鍵の署名に使用し、公開鍵の認定書がその署名ファイル中に含まれます (PKCS #7 ブロック内)。


<h4>JAR ファイル署名</h4>

<p>JAR ファイルに署名することは、指定の署名者の署名を生成することや、指定のJAR ファイルにその署名を含ませることを意味しています。<b>javakey</b>が管理するデータベースには、署名者、関連するペアの鍵および最低 1 つの X.509 認定書があるものとされます。認定書の生成のように、署名の生成はディレクティブベースです。各ディレクティブファイルには署名者の 
<i>profile</i> が含まれます。サンプルのディレクティブファイルでは次のようになります。

<pre>

#
# JAR signing directive. This is the directive file used by javakey to 
# sign a JAR file.
#

# Which signer to use. This signer must be in the database.

signer=duke


# Certificate number to use for this signer. This determines which
# certificate will be included in the PKCS#7 block. This is mandatory
# and is 1-based. Its value should be the number that javakey
# previously assigned to the signer's certificate when it generated it 
# (or imported it). You can see which numbers javakey assigns 
# to certificates by viewing the output of the 
# <code>-ld</code> or <code>-li</code> javakey option. 

cert=1


# Certificate chain depth of a chain of certificates to include. This is
# currently not supported.

chain=0

# The name to give to the generated signature file and associated signature
# block. This must be 8 characters or less.
# The generated signature file and associated signature block will have 
# this name, with the .SF and .DSA extensions, respectively.
# In this example, the files will be DUKESIGN.SF and DUKESIGN.DSA.

signature.file=DUKESIGN


# (Optional) The name to give to the signed JAR file.

out.file=signedJar.jar

</pre>

<p>一度、JAR ファイルやディレクティブファイルが作成されると、javakey コマンドを使用してJAR ファイルに署名します。それは、次のようになります。 

<pre>
    javakey -gs <var>directivefile jarfile</var>
</pre>

<i>directivefile</i> はディレクティブファイルの名前 (とパス) です。<i>jarfile </I> はJAR ファイルの名前 (とパス) です。 

<p>このコマンドの出力は署名済みの JAR ファイルで、そのファイル名は <code>out.file</code> プロパティの値で指定した名前となります。必要があれば、ディレクティブファイルに指定します。<code>out.file</code> プロパティがない場合、署名される JAR ファイル名は最初の JAR ファイルの名前と同じになりますが、サフィックスの <code>.sig</code> が付きます。

<p>生成された .SF と .DSA ファイルは、<code>META-INF</code> ディレクトリの JAR ファイルに追加されます。これらのファイルの基本名が、前記の例のように <code>DUKESIGN</code> の場合、追加ファイルは次のとおりです。

<ul>
<li>META-INF\DUKESIGN.SF
<li>META-INF\DUKESIGN.DSA

</ul>

<p>署名入り JAR ファイルの中で、このような名前のファイルは上書きされます。

<p>

</blockquote>
</blockquote>


<h2><a name=Options>オプション</a></h2>

<blockquote>

注意:  前にあるマイナスサイン (-) があってもなくても、オプションを指定することができます。<i>1つの</i> オプションだけが <b>javakey</b> コマンドで指定することができます。

<dl>

<dt><b><code>-c </code></b><var>identity</var> <code>{true|false}</code>
<dd>
データベースのユーザ名 <i>identity</i> で新しいアイデンティティを作成します。オプションの 
<code>true</code> と <code>false</code> の指定は、信頼できるアイデンティティであるかどうかを指定します(デフォルトは <code>false</code> )。 たとえば、アイデンティティ名 <i>jane</i> を作成し、彼女が信頼されることを指定するには、次のように行います。<P>

<pre>
    javakey -c jane true
</pre>

<dt><b><code>-cs </code></b><var>signer</var> <code>{true|false}</code>
<dd>
データベースユーザ名 <i>signer</i> で、新しい署名者を作成します。オプションの <code>true</code> と <code>false</code> 指定は、その署名者が信頼できるかどうかを指定します。 
<p>

<dt><b><code>-t </code></b><var>idOrSigner</var> <code>{true|false}</code>
<dd>
指定のアイデンティティまたは署名者のための信頼レベルをセット (またはリセット) します。
<p>

<dt><b><code>-l </code></b>
<dd>
<b>javakey</b>が管理しているデータベースの中の、すべてのエンティティ (アイデンティティと署名者) のユーザ名をリストします。
<p>


<dt><b><code><a name=ldOption>-ld </a></code></b>
<dd>
<b>javakey</b>が管理しているデータベースの中の、すべてのエンティティに関する情報を詳細にリストし、提供します。
<p>


<dt><b><code><a name=liOption>-li </a></code></b><var>idOrSigner</var>
<dd>
指定のアイデンティティと署名者に関する情報を詳細に提供します。
<p>


<dt><b><code>-r </code></b><var>idOrSigner</var>
<dd>
データベースから指定のアイデンティティと署名者を削除します。
<p>

<dt><b><code>-ik </code></b><var>identity keysrcfile</var>
<dd>
ファイル <i>keysrcfile</i>の 公開鍵をインポートし、指定の <i>identity</i> と関連付けます。その鍵は X.509 形式でなければなりません。
<p>

<dt><b><code>-ikp </code></b><var>signer pubfile privfile</var>
<dd>
鍵のペア (ファイル <i>pubfile</i>の 公開鍵とファイル <i>privfile</i>の 秘密鍵) をインポートし、指定の <i>signer</i>と関連付けます。その鍵は X.509 形式でなければなりません。
<p>

<dt><b><code>-ic </code></b><var>idOrSigner certsrcfile</var>
<dd>
ファイル <i>certsrcfile</i>の 公開鍵認定書をインポートし、指定のエンティティ (アイデンティティと署名者) と関連付けます。公開鍵がすでに、データベースのエンティティと関連付けられている場合、<i>certsrcfile</i>で証明されている公開鍵と同じであることを <b>javakey</b> が保証します。それが同じでない場合、エラーを報告します。エンティティに関連付けられた公開鍵がまだない場合、<b>javakey</b> は 
<i>certsrcfile</i>の公開鍵を使用して関連付けます。
<p>

<dt><b><code>-ii </code></b><var>idOrSigner</var>
<dd>
指定のアイデンティティと署名者に関する情報を設定します。「情報インポート」コマンドに次のようにタイプした後、

<pre>
    javakey -ii jane
</pre>

<p><i>jane</i>に提供したい情報を何行かタイプし、行の最後に 1 つのピリオドを打って終了させ、情報の終了を示すよう求められます。 
<p>

<dt><b><code>-gk </code></b><var>signer algorithm  keysize {pubfile} 
{privfile}</var>
<dd>
指定の <i>algorithm</i> を使用して、指定の <i>signer</i> に対して、鍵のペア (公開鍵と関連する秘密鍵) を生成し、両方の鍵の長さを <i>keysize</i> ビットにします。ファイル <i>pubfile</i> が指定されている場合、公開鍵はそのファイルに書き込まれます。さらに、ファイル <i>privfile</i> が指定されている場合、秘密鍵もそのファイルに書き込まれます。ここで極めて重要なことは、セキュリティシステムが危険に晒されないように、秘密鍵はプライベートのままにしなければなりません。


<p>アルゴリズムに対する <i>keysize</i> の限界値が、存在する場合には、<i>Java 暗号化アーキテクチャ API 仕様 & 参照</i> の<a href="../../guide/security/CryptoSpec.html#AppB">付録 B</a> に説明されているものになります。
<p>注：<b>javakey</b> は常に、DSA (デジタル署名アルゴリズム) を生成することができます。<b>javakey</b> が異なるアルゴリズムを生成できるのは、(1) 指定した名前が <code>RSA</code> のような <a href="../../guide/security/CryptoSpec.html#AppA">
標準鍵生成アルゴリズム名</a> である場合、および (2) 静的にインストールされた<a 
href="../../guide/security/CryptoSpec.html#Provider">プロバイダ</a>が存在して、指定された鍵生成アルゴリズムの実装を供給する場合に限られます。
<p> DSA アルゴリズムに対する <code>p</code>、<code>q</code>、または<code>g</code>  パラメータのようなアルゴリズム固有鍵生成パラメータを指定する方法がないことに注意してください。
<p>

<dt><b><code>-g </code></b><var>signer algorithm  keysize {pubfile} {privfile}</var>
<dd>
-gk コマンドのショートカットで、指定の署名者の鍵のペアを生成します。
<p>


<dt><b><code><a name=gcOption>-gc </a></code></b><var>directivefile</var>
<dd>

<i>directivefile</i> で提供された情報により、認定書を生成します。<a href = "#CertificateGeneration">認定書の生成</a> を参照してください。
<p>

<dt><b><code>-dc </code></b><var>certfile</var>
<dd>
ファイル <i>certfile</i> に格納された認定書を表示します。
<a href = "#DisplayCertificate">認定書とファイル</a> を参照してください。
<p>

<dt><b><code>-ec </code></b><var>idOrSigner certnum certoutfile</var>
<dd>
指定の 
<i>idOrSigner</i> からファイル <i>certoutfile</i> へ、番号を打った認定書 <i>certnum</i> をエクスポートします。その値は、認定書が生成されたとき (またはインポートされたとき)、<b>javakey</b>が発行者の認定書に、以前に代入した番号でなければなりません。javakeyが認定書に代入した番号を調べるには、<b>-ld</b> (すべてのエンティティ) オプション、または <b>-li</b> (特定のエンティティ) オプションの出力を表示させます。
<p>

<dt><b><code>-ek </code></b><var>idOrSigner pubfile {privfile}</var>
<dd>
指定のアイデンティティまたは署名者のために 公開鍵をエクスポートし、オプションで、秘密鍵 (署名者のために) を指定のファイル (または複数のファイル) にエクスポートします。この鍵は、X.509/DER 形式でコード化します。
<p>

<dt><b><code>-gs </code></b><var>directivefile jarfile</var>
<dd>
<i>directivefile</i> で提供される情報に従い、指定の JAR (Java ARchive) ファイルに署名します。 
<a href = "#JARSigning">JAR ファイルとデジタル署名</a> を参照してください。
<p>

</dl>

</blockquote>


<h2>例</h2>

<blockquote>

<i>jane</i> という名の信頼されるアイデンティティと <i>joe</i> という名の信頼される署名者を作成するには、次のコマンドを使用してください。

<pre>
    javakey -c jane true
    javakey -cs joe true
</pre>

<p><i>jane</i> が電子メールで、彼女の公開鍵を <i>joe</i> に送り、彼が<code>\tmp\jane_pubkey</code> という名前のファイルにその鍵を格納していると仮定します。それは、X.509/DER 形式でコード化されていなければなりません。その鍵をインポートし、<b>javakey</b> が管理する持続データベースの中にある 
<i>jane</i>のアイデンティティと関連付けるには、<i>joe</i> (またはシステム管理者) が次のコマンドを入力します。

<pre>
    javakey -ik jane \tmp\jane_pubkey
</pre>

<p><i>joe</i> が、別のコンテキストで使用した公開鍵と秘密鍵をペアでもっていると仮定してみましょう。今彼は、データベースの中にある自分のユーザ名識別子と、その鍵のペアを関連付けようとします。その公開鍵は <code>\tmp\joe_pubkey</code> に格納されており、その秘密鍵は <code>\tmp\joe_privkey</code> に格納されていると仮定して、彼が行うコマンドは、次のようになります。

<pre>
    javakey -ikp joe \tmp\joe_pubkey \tmp\joe_privkey
</pre>

<p>2 つの鍵は X.509 形式でなければなりません。当然、2 つの鍵は同じアルゴリズムで書かれています。

<p>既存のペアの鍵の代わりに <i>joe</i> の新しいペアの鍵を作るために、使用するコマンドは次のとおりです。

<pre>
    javakey -gk joe DSA 512 \tmp\joe_pubkey
</pre>

<p>このコマンドにより、512 ビットの DSA のペア鍵が作成され、<i>joe</i> と関連付けられます。<b><code>-gk </code></b> もまた、オプションで、ファイルに公開鍵のコピーを保存します。この例では、<code>\tmp\joe_pubkey</code> ファイルを使用しています。<i>joe</i>がファイルに 公開鍵を保存する理由として、<i>jane</i> にその鍵のコピーをメールで送ることができるし、また、その鍵を必要としている (すなわち<i>joe</i>のデジタルシグネチャを証明する) 誰か他の人に、メールで送ることもできます。このコマンドは、オプションの必要があれば 秘密鍵を保存するファイルを <i>joe</i> に指定させることもできます。しかし、秘密鍵をファイルへ保存することについては十分注意する必要があります。

<p><i>joe</i> がファイルに署名する前に、1 つ以上の自分と関連付ける認定書をもち、自分の 公開鍵を認証しなければなりません。自分の認定書を生成するには、ディレクティブファイルをまず作成する必要があります。そのファイルに、<i>joe</i>、認定書発行者および認定書有効日などに関するさまざまな情報を指定します。そのようなファイルが作成され (
<a href = "#Certificates">認定書</a> を参照してください)、そのファイルの名前は <code>joeCertDirectiveFile</code> で、<code>\tmp\</code> ディレクトリにあると仮定します。<i>joe</i> の認定書が作成されるときのコマンドは、次のようになります。

<pre>
    javakey -gc \tmp\joeCertDirectiveFile
</pre>

<a href = "#JARSigning">JAR ファイルとデジタル署名</a> で説明したように、署名入り JAR ファイルも、署名が要求する情報を提供するディレクティブファイルが必要になります。そのような情報は署名者の名前やその署名に使われる認定書の番号などです。<code>jarfileA.jar</code> という名前の JAR ファイルに署名するコマンドは、 <code>joeJarDirectiveFile</code> ディレクティブファイルを使用して、次のようになります。

<pre>
    javakey -gs joeJarDirectiveFile jarfileA.jar
</pre>

</blockquote>


<h2>参照</h2>
<blockquote>

<ul>

<li><a href = "http://java.sun.com/security/usingJavakey.html">
http://java.sun.com/security/usingJavakey.html</a>: 簡潔な自己完結形式の導入チュートリアル<p>

<li><a href="jar.html">jar</a> ツールドキュメント<p>

<li><a href = "http://java.sun.com/security/signExample/">
http://java.sun.com/security/signExample/</a>: JDK 1.1 ツール(<b>javakey</b>, <b>jar</b> と <b>appletviewer</b>) を使用してコード署名をユーザがどのように試すことができるかを示す単純なステップ構成のデモ


</ul>

</blockquote>

</body>
</html>

