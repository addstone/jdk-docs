<html><head><title>オブジェクト直列化ストリームプロトコル
</title></head>
<body bgcolor=#ffffff>
 
<a href="serialTOC.doc.html">[目次]</a> <a href="version.doc.html">[前項目]</a> <a href="security.doc.html">[次項目]</a>
<hr><br>
 
<h1><a name="8101">
オブジェクト直列化ストリームプロトコル

</a></h1>
<hr><p>
<p>
<p><h3><a name="8121">
トピック:
</a></h3><ul><li><a href="protocol.doc.html#8130">概要</a>
<li><a href="protocol.doc.html#8299">ストリーム要素</a>
<li><a href="protocol.doc.html#5849">ストリーム形式の文法</a>
<li><a href="protocol.doc.html#9884">例</a>
</ul><h1><a name="8130">
概要
</a></h1>ストリーム形式は、次の目標を達成するように設計されています。
<p><ul><li>効率的に読み込まれるように簡潔で構造化されている。
<li>ストリームの構造と形式を知っているだけで、ストリームを読み飛ばすことができる。クラスごとのコードを呼び出す必要はない。
<li>データへのストリームアクセスだけが必要である。
</ul><h1><a name="8299">
ストリーム要素
</a></h1>ストリームのオブジェクトを表すには、基本構造が必要です。
オブジェクトの各属性、つまりそのクラス、そのフィールド、およびクラス固有のメソッドによって書き込まれ、後に読み込まれるデータが表されなければなりません。ストリームのオブジェクトの表現は、ある文法によって記述することができます。null オブジェクト、新規オブジェクト、クラス、配列、文字列、およびすでにストリームにあるオブジェクトへのバック参照に対し、特別な表現があります。ストリームに書き込まれた各オブジェクトには、このオブジェクトをバック参照するために使用するハンドルが割り当てられます。ハンドルは、ゼロから始まり順次に割り当てられます。ストリームがリセットされると、ハンドルは再びゼロから始まります。
<p>クラスオブジェクトは次のオブジェクトによって表されます。
<p><ul><li>その ObjectStreamClass オブジェクト
</ul>An ObjectStreamClass オブジェクトは次の要素によって表されます。
<p><ul><li>互換クラスのストリーム固有識別子 (SUID)
<li>そのクラスに writeObject/readObject メソッドがあったかどうかを示すフラグ
<li>nonstatic と nontransient フィールドの数
<li>デフォルトのメカニズムによって直列化される（そのクラスの）フィールドからなる配列。配列とオブジェクトフィールドの場合、フィールドの型は文字列として入れられる。
<li>annotateClass メソッドによって書き込まれる任意指定のブロックデータレコードまたはオブジェクト。
<li>そのスーパー型の ObjectStreamClass（スーパークラスが直列化可能でなければ null ）
</ul>文字列はそれらの UTF コード化によって表されます。修正された UTF の現在の仕様と実装では、コード化された文字列の合計の長さは 65535 文字に制限されますので注意が必要です。
<p>配列は次の要素によって表されます。
<p><ul><li>それらの ObjectStreamClass オブジェクト
<li>要素の数
<li>値の順序。値の型はその配列の型に内在している。たとえば、バイト配列の値の型はバイトである。
</ul>ストリームの新規オブジェクトは次の要素によって表されます。
<p><ul><li>そのオブジェクトの最も多く派生されたクラス
<li>そのオブジェクトのそれぞれの直列化可能クラスのデータ（最も高いスーパークラスが最初）。クラスごとに、ストリームには次のものがある。
<ul>
<li>デフォルトが直列化されたフィールド（対応する ObjectStreamClass の記述によると static とも transient とも記されていないフィールド）
<li>そのクラスに  <code>writeObject</code>/<code>readObject</code> メソッドがあれば、<code>writeObject</code> メソッドによって書き込まれた、プリミティブ型の任意指定のオブジェクトおよび/またはブロックデータレコードと、それに続いて endBlockData がある場合がある。
</ul>
</ul>クラスによって書き込まれたすべてのプリミティブデータは、ブロックデータレコードにバッファされ、ラップされます。これは、そのデータが <code>writeObject</code> メソッドの中でストリームに書き込まれたのか、<code>writeObject</code> メソッドの外から直接ストリームに書き込まれたのかには関係ありません。このデータは、対応する <code>readObject</code> メソッドによって読み込むか、ストリームから直接読み込むことができます。<code>writeObject</code> によって書き込まれたオブジェクトは、前に書き込まれたブロックデータレコードがあればそれを停止し、正規オブジェクト、null、またはバック参照のうち適切なものとして書き込まれます。ブロックデータレコードでは、エラー回復によって任意指定データを破棄することができます。クラスの中から呼び出された場合には、ストリームはデータやオブジェクトを endBlockData まで破棄することができます。
<p>
<p><h1><a name="5849">
ストリーム形式の文法
</a></h1>
<p>
下のテーブルはこの文法を示したものです。非終端記号はイタリックで、終端記号は固定幅のフォントで示します。非終端の定義には、その後に ":"が続きます。定義には 1 つまたは複数の代替定義が続き、それぞれが別の行に示されます。下のテーブルはその表記法を示しています。
<Table Border="3">
<caption></caption>
<tr><th>表記法
<th>意味

<tr><td><em>(datatype</em>)	
<td>このトークンには、バイトなどのデータ型が指定されます。
<tr><td>token[n]
<td>	このトークンの事前に定義されたオカレンス数。これは配列です。
<tr><td><strong>x0001</strong>	
<td>16 進数で表したリテラル値。16 進数の桁数がその値のサイズを表します。
<tr><td>&lt;xxx&gt;
<td>		ストリームから読み込まれた値であり、配列の長さを示すために使用されます。

</Table>

<table>
<tr><td>
</table>

<p><h2><a name="9298">
文法規則
</a></h2>直列化されたストリームは、<em>stream</em> 規則を満たす任意のストリームによって表されます。

<p><dl><pre><em>stream:
	magic version contents
</em></pre><pre><em>contents:
	content
	contents content
</em></pre><pre><em>content:
	object
	blockdata
</em></pre><pre><em>object:
	newObject
	newClass
	newArray
	newString
	newClassDesc
	prevObject
	nullReference
	exception
	TC_RESET
</em></pre><pre><em>newClass:
	<strong>TC_CLASS</strong> classDesc newHandle
</em></pre><pre><em>classDesc:
	newClassDesc
	nullReference
	(ClassDesc)prevObject	// オブジェクトの型は ClassDescでなければならない。
</em></pre><pre><em>superClassDesc:
	classDesc
</em></pre><pre><em>newClassDesc:
	<strong>TC_CLASSDESC</strong> className serialVersionUID	newHandle classDescInfo
</em></pre><pre><em>classDescInfo:
	classDescFlags fields classAnnotation superClassDesc 
</em></pre><pre><em>className:
	(utf)
</em></pre><pre><em>serialVersionUID:
	(long)
</em></pre><pre><em>classDescFlags:
	(byte)	// 終端記号と定数で定義される。
</em></pre><pre><em>fields:
	(short)&lt;count&gt;  fieldDesc[count]	
</em></pre><pre><em>fieldDesc:
	primitiveDesc
	objectDesc
</em></pre><pre><em>primitiveDesc:
	prim_typecode fieldName
</em></pre><pre><em>objectDesc:
	obj_typecode fieldName className
</em></pre><pre><em>fieldName:
	(utf)
</em></pre><pre><em>className:
	(String)object		// フィールドの型を含む文字列
</em></pre><pre><em>classAnnotation:
	endBlockData
	contents endBlockData	// annotateClassによって書き込まれた内容
</em></pre><pre><em>prim_typecode:
	<strong>`B'</strong> 	// byte
	<strong>`C'</strong> 	// char
	<strong>`D'</strong> 	// double
	<strong>`F'</strong> 	// float
	<strong>`I'</strong> 	// integer
	<strong>`J'</strong> 	// long
	<strong>`S' </strong>	// short
	<strong>`Z' </strong>	// boolean
</em></pre><pre><em>obj_typecode:
	<strong>`[`</strong>	// array
	<strong>`L'</strong> 	// object
</em></pre><pre><em>newArray:
	<strong>TC_ARRAY</strong> classDesc newHandle (int)&lt;size&gt; values[size]
</em></pre><pre><em>newObject:
	<strong>TC_OBJECT</strong> classDesc newHandle classdata[]	// 各クラスのデータ
</em></pre><pre><em>classdata:
	nowrclass	// SC_WRRD_METHOD &amp; !classDescFlags
	wrclass objectAnnotation	// SC_WRRD_METHOD &amp; classDescFlags 
</em></pre><pre><em>nowrclass:
	values	// クラス記述子の順序になったフィールド
</em></pre><pre><em>wrclass:
	nowrclass
</em></pre><pre><em>objectAnnotation:
	endBlockData
	contents endBlockData	// writeObjectによって書き込まれた内容
</em></pre><pre><em>blockdata:
	<strong>TC_BLOCKDATA</strong> (byte)&lt;size&gt; (byte)[size]
</em></pre><pre><em>blockdatalong:
	<strong>TC_BLOCKDATALONG</strong> (int)&lt;size&gt; (byte)[size]
</em></pre><pre><em>endBlockData	:
	<strong>TC_ENDBLOCKDATA
</strong></em></pre><pre><em>newString:
	<strong>TC_STRING</strong> newHandle (utf)
</em></pre><pre><em>prevObject	:
	<strong>TC_REFERENCE</strong> (int)handle
</em></pre><pre><em>nullReference	:
	<strong>TC_NULL
</strong></em></pre><pre><em>exception:
<strong>	TC_EXCEPTION reset </strong>(Throwable)object	 reset 
</em></pre><pre><em>resetContext:	
	<strong>TC_RESET
</strong></em></pre><pre><em>magic:	
	<strong>STREAM_MAGIC
</strong></em></pre><pre><em>version	:
	<strong>STREAM_VERSION
</strong></em></pre><pre><em>values:		// サイズと型は現行オブジェクトに対し
		// classDescによって記述される。
</em></pre><pre><em>newHandle:		// 順序にある次の番号が直列化または直列化復元
			// されているオブジェクトに割り当てられる。</em></pre></dl><h2><a name="9303">
終端記号と定数
</a></h2>java.io.ObjectStreamConstants の次の記号は、ストリームで予期される終端値と定数値を定義したものです。
<p><dl><pre>	final static short STREAM_MAGIC = (short)0xaced;
	final static short STREAM_VERSION = 5;
	final static byte TC_NULL = (byte)0x70;
	final static byte TC_REFERENCE = (byte)0x71;
	final static byte TC_CLASSDESC = (byte)0x72;
	final static byte TC_OBJECT = (byte)0x73;
	final static byte TC_STRING = (byte)0x74;
	final static byte TC_ARRAY = (byte)0x75;
	final static byte TC_CLASS = (byte)0x76;
	final static byte TC_BLOCKDATA = (byte)0x77;
	final static byte TC_ENDBLOCKDATA = (byte)0x78;
	final static byte TC_RESET = (byte)0x79;
	final static byte TC_BLOCKDATALONG = (byte)0x7A;
	final static byte TC_EXCEPTION = (byte)0x7B;
</pre></dl>フラグバイト classDescFlags は、次の記号の値をもつことがあります。
<p><dl><pre>	final static byte SC_WRITE_METHOD = 0x01;
	final static byte SC_SERIALIZABLE = 0x02;
	final static byte SC_EXTERNALIZABLE = 0x04;
</pre></dl>ストリームを書き込んでいるクラスに writeObject メソッドがあって、それがストリームに追加データを書き込んだ可能性があると、フラグ SC_WRITE_METHOD はオンに設定されます。この場合には、そのクラスのデータは常に TC_ENDBLOCKDATA マーカーで終わっていなければなりません。
<p>ストリームを書き込んだクラスが <code>java.io.Serializable</code> を拡張したが、java.io.Externalizable は拡張しなかった場合は、フラグ SC_SERIALIZABLE がオンに設定されます。そのストリームを読み込むクラスもまた Serializable を拡張しなければなりません。デフォルトの直列化メカニズムが使用されます。
<p>ストリームを書き込んだクラスが <code>java.io.Externalizable</code> を拡張した場合は、フラグ SC_EXTERNALIZABLE がオンに設定されます。そのデータを読み込むクラスもまた、 Externalizable を拡張しなければなりません。このデータはその writeExternal と readExternal メソッドを使って読み込まれます。
<p><h1><a name="9884">
例
</a></h1>オリジナルクラスと、リンクされたリストの 2 つのインスタンスの場合を想定します。
<p><dl><pre>class List implements java.io.Serializable {
	int value;
	List next;
	public static void main(String[] args) {
		try {
			List list1 = new List();
			List list2 = new List();
			list1.value = 17;
			list1.next = list2;
			list2.value = 19;
			list2.next = null;

			ByteArrayOutputStream o = new ByteArrayOutputStream();
			ObjectOutputStream out = new ObjectOutputStream(o);
			out.writeObject(list1);
			out.writeObject(list2);
			out.flush();
			...
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
}
</pre></dl>結果のストリームの内容は次のようになります。
<p><dl><pre>00: ac ed 00 05 73 72 00 04 4c 69 73 74 69 c8 8a 15 &gt;....sr..Listi...&lt;
</pre><pre>10: 40 16 ae 68 02 00 02 49 00 05 76 61 6c 75 65 4c &gt;Z......I..valueL&lt;
</pre><pre>20: 00 04 6e 65 78 74 74 00 06 4c 4c 69 73 74 3b 78 &gt;..nextt..LList;x&lt;
</pre><pre>30: 70 00 00 00 11 73 71 00 7e 00 00 00 00 00 13 70 &gt;p....sq.~......p&lt;
</pre><pre>40: 71 00 7e 00 03                                  &gt;q.~..&lt;
</pre><pre>
</pre></dl>
<hr><br>
 
<a href="serialTOC.doc.html">[目次]</a> <a href="version.doc.html">[前項目]</a> <a href="security.doc.html">[次項目]</a>
<hr><br>
 
<i>Copyright (C) 1996, 1997 Sun Microsystems, Inc.  All rights
reserved.</i>

<!-- This file was created with Quadralay WebWorks Publisher 3.0.4 -->
<!-- -->
<!-- For more information on how this document, and how the rest of -->
<!-- this server was created, email rmi-support@javasoft.com -->
<!-- -->
<!-- Last updated: 02/04/97 19:22:12 -->

</body>
</html>
