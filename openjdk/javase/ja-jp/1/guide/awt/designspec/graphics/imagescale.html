<html>
<head>
<title>AWT イメージスケーリング API</title>
</head>
<BODY BGCOLOR="#FFFFFF">
 
<h1>AWT イメージスケーリング API</h1>
<hr>
<address>最終更新: 1996 年 10 月 30 日</address>
<h2>問題</h2>
Java は、 drawImage() が呼び出されたときに自動的にイメージをスケールする多くの機構を提供します。これらの機構は、正確な動作がうまくドキュメント化されておらず、参照ポートに選択された特定の実装がほとんどのプログラマの期待と異なる動作をするため、混乱を生じています。
<p>
とりわけ、イメージが画面に表示されるとき、Image データは画面の配色機能に適合するフォーマットに変換されます。元のイメージデータは持続的に格納されず、変換された画面データだけが画面表示によって格納されます。イメージのデータが他の目的（新しいイメージのためのデータのフィルタリングなど）で必要な場合、生のデータを元のソースから再ロードする必要があります。
<dl>
<dd>第 2 の目的のために最初にロードした直後に、元のデータが必要な場合、それはキャッシュに格納されています。単一のイメージがいくつかのフィルタを通して実行される場合、後続のフィルタをかけたイメージは、イメージファイルをソースから再ロードせずに、しばしばキャッシュされた変換データを使用することができます。しかし、このキャッシュされたデータは一般的に信頼できません。
</dl>
幅と高さの仕様を設定できる drawImage メソッドの変異形の 1 つを使用してイメージをスケールするとき、別個の画面表示が、描画されたサイズに対して作成されます。さらに、8 ビット画面上の出力用にディザされた後イメージをスケールすると、非常に貧弱な出力品質になるため、スケーリングは常に元のイメージデータから行います。たとえ、画面が 24 ビットの深さで、画面表示に元のイメージデータが変換損失なしで含まれるとしても、この実装はローカルコピーを使用するにはあまり賢明ではなく、イメージのソースデータを使うほうがいいでしょう。
<p>
描画された各サイズに対して別個のイメージ表示を格納することに関するもう 1 つの欠点は、消費するメモリの量です。描画された各サイズに対して別個の表示を格納する方策は、データがすべて画面にバイト単位でコピーされるため、レンダリング速度を最小化することを意味します。この方策は逆効果で終わります。それは、スケールサイズの事前計算による速度利得は、しばしばスケールされた変異形がロードされ変換される間待つ苦痛と不便さによって、それ以上に相殺されるからです。イメージデータを遅いネットワーク上で再ロードする必要がある場合、特にそうなります。また、イメージが決して繰り返されず多数の異なるサイズで描画されている場合、スケールされた表示をキャッシュするために使用するメモリが浪費されます。
<p>
要するに、イメージのスケールされたバージョンが後続のレンダリングにキャッシュされるかどうか、イメージスケーリングが直ちに行われるかまたはバックグラウンドで行われるかを、プログラマは制御できません。
<p>
開発者を悩ます別の問題は、既存のイメージのスケールビューを表わす新しいオブジェクトを作成する方法がないことです。Image オブジェクトは新しい幅と高さのパラメータを drawImage 呼び出しに与えることでスケールできますが、その情報を Image オブジェクトにカプセル化し、その Image オブジェクトを渡すことによって希望するサイズのイメージを描画する方法はありません。

<h2>新しいイメージスケーリング APIとその動作</h2>
この問題を解決するために、イメージをスケールする drawImage メソッドに新しい方策
が適用されます。1.1 では、drawImage によるすべてのスケーリングは、レンダリングの際、全サイズ画面表示から瞬く間に行われます。
<p>
この変更には 2 つの主な欠点があります。
<ol>
<li>
イメージをスケールするために新しい drawImage を使用すると、ピクセルの再順番付け
をレンダ時に実行する必要があるため、以前より若干長く時間がかかります。
<li>
スケールされたイメージの質は、ピクセルの再順番付けがディザリングプロセスの後行われるため、8 ビットでは悪くなります。
</ol>
<p>
後で分かったことですが、最初の問題は当初恐れていたよりは大きなものではありません。過去 2、3 年、プロセッサはメモリシステムとの比較で特に速くなっています。結果として、イメージスケーリングのパフォーマンスはほとんどメモリアクセス速度によって制限され、希望する特定のスケーリングのために画面にコピーする次のピクセルがどれかを決定するために必要な計算は、データを画面に移動する作業に比べてさほど顕著ではありません。
<p>
品質の問題は主要な問題になったかもしれません。1.1 以前の JDK 実装に使用された 8 ビット色変換コードに関しては、ディザリングの後にスケールされた場合、イメージが劇的に劣化しました。幸い、新しい色変換アルゴリズムが 1.1 用に開発され、結果のディザイメージの品質が向上しました。ディザ表示のスケーリングの結果は、スケーリングの後にディザされる 1.0.2 イメージの結果よりよいということはないにしても、通常同じくらいになりました。
<p>
イメージスケーリングの実装は 1.1 で強化され、レンダ時に即座のスケーリングを可能にしましたが、依然、プログラマがスケールされたイメージの品質を向上するあらゆる可能な手段を取るよう希望するケースがあります。プログラマが明示的なスケーリングをレンダリング時の代わりにいつ実行するかを選択できるようにするために、2 つの新しいフィルタクラスが使用可能になり、新しい便利なメソッドが 1.1 の AWT Image クラスに追加されます。この同じ API をプログラマが使用して、自分自身の Image オブジェクトにカプセル化されるイメージのスケールされたバージョンを表す新しい Image オブジェクトを作成することできます。
新しいイメージスケーリングクラスには次のものがあります:
<pre>	<a href="../../../../api/java.awt.image.ReplicateScaleFilter.html">java.awt.image.ReplicateScaleFilter</a>
	<a href="../../../../api/java.awt.image.AreaAveragingScaleFilter.html">java.awt.image.AreaAveragingScaleFilter</a>
</pre>
Image クラスの新しいメソッドは次のとおりです:
<pre>	<a href="../../../../api/java.awt.Image.html#getScaledInstance">getScaledInstance(int width, int height, int hints)</a>
</pre>
ヒントパラメータは、イメージをスケールするためにどの種のアルゴリズムを使用するかを制御します。使用する固有のアルゴリズムを参照するヒントがあり、速度や品質のために操作を最適化するかどうかを指摘する、もっと抽象的なヒントがあります。ヒントパラメータの適正な値のセットは現在次のとおりです:
<pre>Image.SCALE_DEFAULT</pre>
<dl><dd>
デフォルトスケーリングアルゴリズムを使用する（ユーザ構成に基づき選択可能）
</dl>
<pre>Image.SCALE_FAST</pre>
<dl><dd>
スケールされたイメージの滑らかさより速度を最適化するスケーリングアルゴリズムを選択する
</dl>
<pre>Image.SCALE_SMOOTH</pre>
<dl><dd>
速度よりスケールされたイメージの滑らかさを最適化するスケーリングアルゴリズムを選択する
</dl>
<pre>Image.SCALE_REPLICATE</pre>
<dl><dd>
ReplicateScaleFilter によって実装されたアルゴリズムを使用する
</dl>
<pre>Image.SCALE_AREA_AVERAGING</pre>
<dl><dd>
AreaAveragingScaleFilter によって実装されたアルゴリズムを使用する
</dl>

<h2>サンプルコード</h2>
イメージをスケールするための新しい API の使用方法を示すサンプルコードを、次に示します:
<pre>

    import java.awt.*;
    import java.applet.*;

    public class ImgScaleExample extends Applet {
	Image img, img2;
    	public void init() {
	    img = getImage(getDocumentBase(), "foo.gif");
	    img2 = img.getScaledInstance(100, 100, Image.SCALE_DEFAULT);
	}

	public void paint(Graphics g) {
	    // Draw the full size image
	    g.drawImage(img, 0, 0, this);
	    // Draw the scaled version of the image
	    g.drawImage(img2, 10, 10, this);
	    // Now draw a scaled version of the scaled image
	    g.drawImage(img2, 110, 10, 50, 50, this);
	}
    }
</pre>

<hr><br>

<address>
フィードバックは <a href="mailto:java-awt@java.sun.com">java-awt@java.sun.com</a> 宛てに送ってください。
</address>

<i>Copyright (C) 1996, Sun Microsystems, Inc.   All rights
reserved.</i>

</body>
</html>
