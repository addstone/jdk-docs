<html><head><title>システムアーキテクチャ
</title></head>
<body bgcolor=#ffffff>
 
<a href="rmiTOC.doc.html">目次</a> <a href="rmi-objmodel.doc.html">前項目</a> <a href="rmi-client.doc.html">次項目</a>
<hr><br>
 
<a name="60">
<h1>システムアーキテクチャ
</h1>
</a>
<hr><p><a name="64">

<p>
</a><h3><a name="65">
トピックス:
</a></h3><ul><li><a href="rmi-arch.doc.html#194">概要</a>
<li><a href="rmi-arch.doc.html#200">アーキテクチャの概要</a>
<li><a href="rmi-arch.doc.html#240">スタブ/スケルトン層</a>
<li><a href="rmi-arch.doc.html#583">リモート参照層</a>
<li><a href="rmi-arch.doc.html#264">トランスポート層</a>
<li><a href="rmi-arch.doc.html#5112">リモートメソッド呼び出しにおけるスレッドの使用法</a>
<li><a href="rmi-arch.doc.html#5097">リモートオブジェクトのガベージコレクション</a>
<li><a href="rmi-arch.doc.html#280">クラスのダイナミックローディング</a>
<li><a href="rmi-arch.doc.html#4041">セキュリティ</a>
<li><a href="rmi-arch.doc.html#4018">コンフィギュレーションシナリオ</a>
<li><a href="rmi-arch.doc.html#4799">プロキシ経由で RMI をファイアウオールを通して使う</a>
</ul><h1><a name="194">
概要
</a></h1>RMI システムは<em>スタブ/スケルトン層</em>、<em>リモート参照層</em>、<em>トランスポート層</em>の3つの層から構成されます。各層の境界は特定のインタフェースとプロトコルで定義され、それぞれの層は隣接する層とは独立に存在し、システムの他の層に影響を及ぼすことなしに別の実装と入れ替えることも可能です。例えば、現在のトランスポート層は TCP-ベース（Java socketsを使用）の実装ですが、これを UDP ベースのトランスポートへ入れ替えることも可能です。
<p>オブジェクトを一つのアドレス空間から他のアドレス空間へユーザから見て透過的な方法で伝達するために、オブジェクト直列化（Java 言語に特有の設計です）という技術が使われます。
オブジェクト直列化についてはこの章ではプリミティブとオブジェクトの整列化に関連した部分のみを説明します。更に完全な内容については<em>オブジェクト直列化仕様</em>を参照してください。
<p><em>ダイナミックスタブローディング</em>という別な技術により、クライアント側のスタブがリモートオブジェクト自体と同じリモートインタフェースを実装することが可能になります。 
この技術は、クライアント側で厳密な型のスタブがまだ利用できないときに、クライアントが型キャストと型チェックのために Java 言語の組み込み演算子を使えるようにします。
<p><h1><a name="200">
アーキテクチャの概要
</a></h1>RMI システムは3つの層から構成されます。
<p><ul><li>スタブ/スケルトン層 - クライアント側スタブ（プロキシ）とサーバ側スケルトン
<li>リモート参照層 - リモート参照の動作（例えば単一オブジェクトや複製オブジェクトの呼出し）
<li>トランスポート層 - 接続のセットアップと管理、およびリモートオブジェクトのトラッキング
</ul>アプリケーション層は RMI システムの上に存在します。次の図が層の相互関係を示します。
<p><a name="983">
 <center><img src="rmi-arch.doc.anc.gif"></center>
<p>
</a>クライアントからのリモートサーバオブジェクトへのリモートメソッド呼び出しは、クライアント側の RMI システムを下に降りてトランスポートへ達し、次にサーバ側のトランスポートから上へ伝わってサーバに達します。
<p>リモートサーバオブジェクト上のメソッドを呼び出すクライアントは実際にはリモートオブジェクトの<em>スタブ</em>またはプロキシをリモートオブジェクトへの通路として利用します。クライアント側が持っているリモートオブジェクトへの参照はローカルスタブへの参照です。
このスタブはリモートオブジェクトのリモートインタフェースの実装であり、リモート参照層を経由して、サーバオブジェクトへ呼び出し要求を転送します。
スタブは rmic コンパイラにより生成されます。
<p><em>リモート参照層</em> は呼び出しの意味解析を司ります。例えば、サーバが単一のオブジェクトなのか、あるいは複製オブジェクトで複数のロケーションとの通信が必要なのかを決定するのはリモート参照層の仕事になります。
リモートオブジェクトの実装はそれぞれが自分のリモート参照セマンティクスを選択します −サーバが単一オブジェクトなのか、あるいは自分自身の複製との通信を必要とする複製オブジェクトなのかを選択します。
<p>サーバへの参照のセマンティクスもリモート参照層が取り扱います。
例えば、リモート参照層はオブジェクト参照方法の違いを抽出して、(a) そのサーバはあるマシン上で常時実行されているのか、(b) そのサーバはメソッド呼び出しが起こったときだけ活性化されて実行する実装になっているのかを判定します。
リモート参照層の上に位置する層からはこれらの差を認識することができません。
<p><em>トランスポート層</em> は接続のセットアップ、接続管理、そしてトランスポートのアドレス空間にあるリモートオブジェクト（リモート呼び出しのターゲット）のトラッキングとディスパッチを司ります

<p>リモートオブジェクトへのディスパッチのために、トランスポートはリモート呼び出しをその上にあるリモート参照層に伝えます。リモート参照層は要求をサーバ側スケルトンに渡す前にサーバ側が必要とする動作をすべて取り扱います。
リモートオブジェクトのスケルトンは、実際のメソッド呼出しを実行するリモートオブジェクトの実装への呼び出しを作成します。
<p>
呼び出しに対する返り値はスケルトンを通ってリモート参照層へ伝えられ、サーバ側のトランスポートへ伝えられ、次にトランスポートを通過して上に進みリモート参照層を通ってクライアント側のスタブに到達します。
<p><h1><a name="240">
スタブ/スケルトン層
</a></h1>スタブ/スケルトン層はアプリケーション層と他の RMI システムとのインタフェースです。この層はトランスポートの詳細を取り扱うものではありませんが、<em>marshal ストリーム</em>での抽象化を介してデータをリモート参照層へ送ります。
marshal ストリームは<em>オブジェクト直列化</em>という機構によりアドレス空間内での Java オブジェクトの伝送を可能にします。 
オブジェクト直列化システムを使って伝送されたオブジェクトは、それがリモートオブジェクトでなければ、リモートアドレス空間へコピー渡しされます。もしリモートオブジェクトであれば参照渡しされます。
<p>リモートオブジェクトへの<em>スタブ</em>とはリモートオブジェクトへのクライアント側のプロキシです。 
このようなスタブはリモートオブジェクトの実装がサポートするすべてのインタフェースを備えています。
クライアント側のスタブは次の役目を果たします。
<p><ul><li>リモート参照層を呼び出すことにより、リモートオブジェクトへの呼び出しを初期化する。
<li>引数を1つに結合してリモート参照層から得られる marshalストリームへ渡す。
<li>リモート参照層に呼び出しを行うように通知する。
<li>marshal ストリームから返り値または例外を取り出し、元に戻す。
<li>リモート参照層に呼び出しが完了したことを通知する。
</ul>リモートオブジェクトの <em>スケルトン</em>は実際のリモートオブジェクトの実装に対して呼び出しを割り当てるメソッドを含んだサーバ側のコンポーネントです。
スケルトンは次の役目を果たします。 
<p><ul><li>marshal ストリームからの引数を元の形に分解して戻す。
<li>実際のリモートオブジェクト実装に上げる呼び出しを作成する。
<li>呼び出しに対する返り値や例外（もし発生すれば）を1つに結合して marshal ストリームに乗せる。
</ul>どのスタブまたはスケルトンクラスを使うかは実行時に決定され、必要に応じて動的にロードされます。詳細は <a href="rmi-arch.doc.html#280">ダイナミッククラスローディング</a>で解説されます。 
スタブとスケルトンは rmic コンパイラにより生成されます。
<p><h1><a name="583">
リモート参照層
</a></h1>リモート参照層はより低いレベルでのトランスポートインタフェースを扱います。この層はクライアントスタブとサーバスケルトンから独立した、特定のリモート参照プロトコルの実行についても責任を持ちます。 
<p>それぞれのリモートオブジェクトの実装は自分用のリモート参照サブクラスを選択します。この層では、次に示す例のように種々の呼び出しプロトコルが実行可能です。
<p><ul><li>ユニキャスト point-to-point 呼び出し。
<li>複製オブジェクトグループへの呼び出し。
<li>特定の複製化戦略のサポート。
<li>リモートオブジェクトへの持続性のある参照のサポート（リモートオブジェクトのアクティベーションを可能にする）。
<li>再接続戦略 (リモートオブジェクトがアクセスできなくなった場合)。
</ul>リモート参照層はクライアント側とサーバ側のコンポーネントという2つの協調して働くコンポーネントを持ちます。クライアント側のコンポーネントはリモートサーバ（リモート参照が複製オブジェクトに対してならば複数のサーバ）に特有な情報を持っており、トランスポートを介してサーバ側のコンポーネントと交信します。
各メソッド呼び出しの期間中に、クライアントとサーバ側のコンポーネントは特定のリモート参照セマンティクスを実行します。例えば、リモートオブジェクトが複製オブジェクトの一部であるならば、クライアント側のコンポーネントは呼び出しを単一のリモートオブジェクトだけにではなくそれぞれの複製に呼び出しを転送します。
<p>同じような方法で、サーバ側コンポーネントは、スケルトンにリモートメソッド呼び出しを伝達するのに先立ち、特定のリモート参照セマンティクスを実装します。このコンポーネントは例えば、複製グループの他のサーバと交信しながら強力なマルチキャストデリバリーを取り扱います（マルチキャストデリバリは JDK 1.1 リリースの RMI には含まれないことに注意）。
<p>リモート参照層はストリーム指向<em>接続</em>の abstraction を介してトランスポート層への伝達を行います。接続実装の詳細はトランスポートが取り扱います。
接続はストリームをベースとするインタフェースを表しますが、その抽象化の下では接続のないトランスポートを実装することも可能です。 
<p><h1><a name="264">
トランスポート層
</a></h1>一般的には、RMI のトランスポート層は次の項目に対して責任を負います。
<p><ul><li>リモートアドレス空間への接続のセットアップ。
<li>接続の管理。
<li>接続が"生きている"かどうかの監視。
<li>入ってくる呼び出しの受け取り。
<li>アドレス空間に存在するリモートオブジェクトのテーブルの保守。
<li>入ってくる呼び出しのための接続セットアップ。
<li>リモート呼び出しの対象のためのディスパッチャの所在検出と、このディスパッチャへの接続を渡す。
</ul>リモートオブジェクト参照の具体的な表現はエンドポイントとオブジェクト識別子で構成されます。この表現を <em>live reference</em> と呼びます。 
リモートオブジェクトへの live reference を与えらたならば、トランスポートはエンドポイントを使ってリモートオブジェクトが存在するアドレス空間への接続セットアップが可能になります。サーバ側では、トランスポートはオブジェクト識別子を使ってリモート呼び出しの対象をさがすことができます。
<p>RMI システムのトランスポートは4つの基本的な abstraction から構成されます。
<p><ul><li><em>エンドポイント</em> はアドレス空間又は Java 仮想マシンの指定に用いられる abstraction である。実装する場合は、エンドポイントを自分のトランスポートへマッピングすることができる。すなわち、エンドポイントを指定することで、特定のトランスポートインスタンスが得られる。
<li> <em>チャネル</em> とは2つのアドレス空間を結ぶ通路の abstraction である。チャネルはローカルアドレス空間とリモートアドレス空間を結ぶ接続のマッピングに責任を負う。
<li><em>接続</em> とはデータ転送（入出力操作の実行）の abstraction である。
<li><em>トランスポート</em> abstraction はチャネルを管理する。各チャネルは2つのアドレス空間を結ぶ仮想的な接続である。トランスポートの内部では、一つのアドレス空間ペア（ローカルアドレス空間とリモートアドレス空間）を結ぶチャネルはただ一本だけである。リモートアドレス空間へのエンドポイントが与えられると、トランスポートがそのアドレス空間へのチャネルをセットアップする。トランスポート abstraction はそのアドレス空間への接続上の呼び出しの受信、その呼び出しに対する接続オブジェクトのセットアップ、そしてシステムの上位の層へのディスパッチにたいしても責任を負う。
</ul>エンドポイントが具体的に何を表現するかはトランスポートが定義します。従って、トランスポートの多重実装もあり得ます。 設計と実装によっては一つのアドレス空間への多重トランスポートはサポート可能であり、同じ仮想マシン内で TCP と UDP 両方をサポートすることもできます。ただし、RMI トランスポートインタフェースは仮想マシンの実装において利用可能であり、直接アプリケーションからは利用できないことに注意してください。
<p><h1><a name="5112">
リモートメソッド呼び出しにおけるスレッドの使用法
</a></h1>RMI ランタイムがリモートオブジェクトの実装（サーバ）へメソッドをディスパッチすると、そのメソッドは別なスレッドで実行される場合とそうでない場合が出てきます。同一のクライアント仮想マシンから発生した呼び出しのうちの幾つかが同一のスレッド内で実行され、また幾つかは他のスレッドで実行されます。
異なるクライアント仮想マシンから発生した呼び出しはそれぞれ異なるスレッドで実行されます。最後に説明した異なるクライアント仮想マシンのケースを除くと、RMI ランタイムはリモートオブジェクト呼び出しとスレッドのマッピングに対して何の保証も行いません。 
<p><h1><a name="5097">
リモートオブジェクトのガベージコレクション
</a></h1>ローカルシステムにおけるのと同様に、分散システムにおいても、どのクライアントからも参照されなくなったリモートオブジェクトは自動的に削除されるのが望ましいことです。
これによりプログラマはリモートオブジェクトのクライアントを追跡して、適切な時期にリモートオブジェクトを終了させるという仕事から解放されます。RMI は参照をカウントする方式の、Modula-3 の Network Objects に似たガベージコレクションアルゴリズムを採用しています。( Birrell, Nelson, Owickiによる次の文献を参照。"Network Objects" <em>Digital Equipment Corporation Systems Research Center Technical Report 11</em>5, 1994.)
<p>参照カウント式ガベージコレクションを実行するために、RMI のランタイムは各 Java 仮想マシン内で生き残っている参照を常に監視しています。
生きた参照が Java 仮想マシンに入ってくると参照カウントは増加します。あるオブジェクトへの最初の参照は「参照が起こった」というメッセージをそのオブジェクトのサーバへ送ります。生きた参照がローカルな仮想マシン内で参照されていないことが分かると、ファイナライズされてカウントは減少します。最後の参照が廃棄されると、「参照されていない」というメッセージがサーバに送られます。このプロトコルには微妙な点が数多くありますが、それらは大部分参照と非参照メッセージの順序を正しく管理してオブジェクトが不必要に回収されるのを防ぐことを保証します。
<p>リモートオブジェクトがどのクライアントからも参照されていない状態になると、RMIランタイムは、そのオブジェクトを弱い参照（weak reference）によって参照します。 弱い参照になると Java 仮想マシンのガベージコレクタは、もしそのオブジェクトへのローカル参照が他に存在しなければ、オブジェクトは廃棄します。分散ガベージコレクションアルゴリズムは、オブジェクトへのノーマルな参照と弱い参照を保持しながら、ローカル Java 仮想マシンのガベージコレクタと相互作用を続けます。 通常のオブジェクトのライブサイクルと同様に、ガベージコレクタがそのオブジェクトへの参照はもはや存在しないと判断すると <code>finalize</code> が呼び出されます。
<p>リモートオブジェクトへのローカルな参照が存在している間はガベージコレクトされることはなく、オブジェクトはリモート呼び出しに渡されたり、クライアントに返されたりします。リモートオブジェクトを渡すと、それが渡された仮想マシンの識別子が参照セットへ追加書き込みされます。 

非参照の通知を必要とするリモートオブジェクトは <code>java.rmi.server.Unreferenced</code> インタフェースを実装しなければなりません。これらの参照が存在しなくなると <code>unreferenced</code> メソッドが呼び出されます。 
<code>unreferenced</code> は参照セットが空であると呼び出されますから、このメソッドは複数回呼び出されることがあります。リモートオブジェクトが回収されるのは、リモートとローカルを含めて参照が全く無くなった場合だけです。
<p>もし、クライアントとリモートサーバの間にネットワークパーティションが存在すると、リモートオブジェクトのコレクションが早すぎる時期に起こり得ます (トランスポートがクライアントがクラッシュしたと判断するかもしれないからです)。
 時期尚早な回収の可能性があるため、リモート参照は参照に関する完全な整合性を保証するものではありません。別な言葉で言えば、リモート参照が実際に存在するオブジェクトを参照していない可能性が常に存在するということです。対象を持たない参照を使おうとすると <code>RemoteException</code> が発生し、その取り扱いはアプリケーションが行わなければなりません。
<p><h1><a name="280">
クラスのダイナミックローディング
</a></h1>RPC (remote procedure call) システムでは、リモートプロシージャ呼び出しが起こる前に、クライアント側のスタブコードが作成されてクライアントにリンクされている必要があります。このコードは静的にクライアントにリンクされる場合と、ローカルまたはネットワークファイルシステムに存在するライブラリの動的リンクによりランタイムにリンクされる場合があります。どちらの場合であっても、RPC を取り扱う特定のコードはコンパイルされた形態でクライアントマシンから利用できなければなりません。
<p>RMI はこのテクニックを一般化し、動的クラスローディングと呼ばれるメカニズムによりリモートオブジェクトのメソッド呼び出しに必要なクラスを（Java言語のアーキテクチャでいうところのニュートラルなバイトコードとして）ランタイムにローディングします。
これらのクラスは：
<p><ul><li>リモートオブジェクトとそのインタフェースクラス。
<li>リモートオブジェクトのプロキシとして働くスタブとスケルトンクラス。（スタブとスケルトンは <code>rmic</code> コンパイラにより作成する。）
<li>他のクラスの中で、RMI ベースのアプリケーションで直接使われるもの、例えばリモートメソッド呼び出しで渡される引数とか返り値。 
</ul>この章では次の内容を説明します。
<p><ul><li>RMI ランタイムはどのようにしてクラスローダと、クラスを読み出す場所を選択するのか。
<li>Java アプリケーションのすべてのクラスをネットワークからダウンロードさせるのか。
</ul>クラスローダに加えて、動的クラスローディングは他に二つのメカニズムを用います。その一つはクラスをワイヤ伝送するオブジェクト直列化システムであり、他方はローディングされたクラスをチェックするセキュリティマネージャです。
オブジェクト直列化に関する議論はしては<em>オブジェクト直列化仕様</em>、セキュリティの問題に関しては <a href="rmi-arch.doc.html#4041">セキュリティ</a>を参照してください。
<p><h2><a name="3932">
クラスローダはどのようにして選択されるか
</a></h2>
Java では、最初に Java クラスをロードするクラスローダがその後も使われてすべてのインタフェースと,そのクラスが直接使用するすべてのクラスをロードします。
<p>
<ul><li>AppletClassLoader は Java アプレットを、&lt;APPLET&gt; タグを持つ web ページの codebase 属性で指定される場所からネットを介してダウンロードする。アプレットが直接使用するクラスもその後 AppletClassLoaderによってロードされる。
<li>クラス（<code>main</code> メソッドが <code>java</code> コマンドで実行される）はデフォルトのクラスローダによりローカル CLASSPATH で指定される場所からロードされる。このクラスが直接使用するすべてのクラスも順次デフォルトクラスローダによりローカル CLASSPATH で指定される場所からロードされる。
<li>クライアントまたはサーバアプリケーションで直接使われる以外のクラスをロードするには RMIClassLoader を使用する。リモートオブジェクトのスタブとスケルトン、RMI 呼び出しの引数、返り値などの拡張されたクラスがこれにあたる。
 RMIClassLoaderは 該当するクラスを次の場所でを上から順番に探す。
<ol>
<li>ローカル CLASSPATH ローカルに存在するクラスは常にローカルにロードされる。
<li>パラメーターまたは返り値として渡されるオブジェクト（リモートおよび非リモート共通）の場合、直列化されたオブジェクトを含む整列ストリームに埋め込まれた URL を使ってオブジェクトのクラスの所在を決定する。
<li>ローカル仮想マシン上で作成されたリモートオブジェクトのスタブとスケルトンには、ローカル <code>java.rmi.server.codebase</code> プロパティのURLが使用される。
</ol>
</ul>パラメータまたは返り値として渡されるオブジェクト（上で説明した第二のケース）では、あるオブジェクトのクラスのためストリームにエンコードされた URL は次の手順で決定されます。
<p><ul><li>もしクラスが（デフォルト以外の）クラスローダによってロードされた場合は、そのクラスローダの URL を使用する。
<li>それ以外の場合には、もし定義されていれば、<code>java.rmi.server.codebase</code> URL を使用する。
</ul> したがって、クラスが CLASSPATH からロードされたときには、codebase URL はそのクラスが RMI 呼び出しで使用されるときのストリーム上での注釈としてのみ使用されます。
<p>アプリケーションは <code>java.rmi.server.useCodebaseOnly</code>プロパティによって構成することができ、ネットワークホストからのクラスローディングを禁止して, ローカルに定義された codebase からのみロードさせることができます。 
必要なクラスがロードできなければ、メソッド呼び出しは例外を発生して失敗します。
<p><h2><a name="3933">
クライアントのブートストラッピング
</a></h2>RMI ランタイムがクライアントアプリケーションが必要とする<em>すべての</em>クラスとインタフェースをロードできるためには、ブートストラッピングクライアントプログラムが必要であり、これがデフォルト以外のクラスローダ（例えば RMI クラスローダ）使用を強制します。 ブートストラッピングプログラムは次の条件を満たさなければなりません。
<p><ul><li><code>RMISecurityManager</code> のインスタンスを作成するか、ユーザ定義のセキュリティマネージャを作成する。
<li>クライアントのクラスをロードするために <code>RMIClassLoader.loadClass</code> メソッドを使用する。コード中にクラスの名前を陽に記述することが出来ないが、文字列またはコマンドライン引数として与えなければならない。そうしないとデフォルトローダがクラスファイルをローカル CLASSPATH からロードしようとする。
<li><code>newInstance</code> メソッドを使ってクライアントのインスタンスを作成し、それを <code>Runnable</code> にキャストする。クライアントは <code>java.lang.Runnable</code> インタフェースを実装しなければならない。<code>Runnable</code> インタフェースは実行スレッドをスタートさせるよく定義されたインタフェースを提供する。
<li> <code>run</code> メソッド (<code>Runnable</code> インタフェースに含まれる)を呼び出ししてクライアントをスタートさせる。
</ul>プログラム例:
<p><dl><a name="3363"><pre>import java.rmi.RMISecurityManager;
import java.rmi.server.RMIClassLoader;

public class LoadClient
{
	public static void main()
	{
		System.setSecurityManager(new RMISecurityManager());
</pre></a><a name="5052"><pre>		try {
			Class cl = RMIClassLoader.loadClass("myclient");
			Runnable client = (Runnable)cl.newInstance();
			client.run();
		} catch (Exception e) {
			System.out.println("Exception: " + e.getMessage());
			e.printStackTrace();
		}
	}
}
</pre></a></dl>このコードがうまく動くためには、ブートストラッピングプログラムを実行するときに java.rmi.server.codebase プロパティを指定して、<code>loadClass</code> メソッドが URL によってクラスをロードするようにしなければなりません。 
例えば:
<p><dl><a name="3459"><pre>java -Djava.rmi.server.codebase=http://host/rmiclasses/ LoadClient
</pre></a></dl>プロパティを用いる代わりに、自分自身の URL を提供することも可能です。
<p><dl><a name="5178"><pre>Class cl = RMIClassLoader.loadClass(url, "myclient");
</pre></a></dl>クライアントがスタートしてコントロールを持っていると、クライアントが必要とするすべてのクラスを特定の URL からロードさせることが可能です。このブートストラッピングテクニックは、アプレットが使用する同じクラスを AppletClassLoader を使って強制的にロードさせたのと全く同じ手法です。
<p>このブートストラッピングテクニックを使わない場合は、クライアントのコードで直接参照されるクラスはクライアントの CLASSPATH の下になければなりません。しかも RMIClassLoader を使ってネットからダウンロードできる Java クラスはクライアントプログラムからは直接参照できないのです。これらのクラスにはスタブ、スケルトンそしてリモートメソッド呼び出しのパラメーター、返り値として使われる拡張クラスがあります。<p><h1><a name="4041">
セキュリティ
</a></h1>Java の場合は、クラスローダがローカル CLASSPATH からクラスをローディングすると、これらのクラスは信頼できるものとして扱われ、セキュリティマネージャからの制限を受けません。しかし、RMIClassLoader がネットワークからクラスをローディングするときは、セキュリティマネージャが存在しなければならず、もしない場合は例外がスローされます。
<p>セキュリティマネージャは Java プログラムの最初のアクションとして起動され、それ以後の動作を管理できなければなりません。セキュリティマネージャはロードされたクラスが Java の標準的な安全規約に従っていることを保証します。クラスが信頼できるソースからロードされたか（例えばアプレットホスト）とか危険性のある機能にアクセスしなかったか等のチェックを行います。セキュリティマネージャが課す制限についての完全な解説は <code>AppletSecurity</code> クラスや <code>RMISecurityManager</code> <code>RMISecurityManager</code> クラスのドキュメントで読むことができます。
<p>アプレットは常に <code>AppletSecurity</code> クラスの課す制限下にあります。セキュリティマネージャはクラスがアプレットホストかまたは信頼のおける codebase ホストのみからロードされるのを保証します。このため、アプレット開発者はアプレットホスト上に必要なクラスをインストールしなければなりません。 
<p>アプリケーションは自分のセキュリティマネージャを定義するか、または強い制限を課する <code>RMISecurityManager</code> を使うことになります。セキュリティマネージャが置かれていない場合は、アプリケーションはネットワークからクラスをロードすることができません。
<p>クライアントやサーバプログラムは通常、ローカルシステムからロードされたクラスによって実装されますからセキュリティマネージャからの制限を受けません。しかし、クライアントプログラム自体が<a href="rmi-arch.doc.html#3933">クライアントのブートストラッピング</a>に解説されている方法でネットワークからダウンロードされた場合には、クライアントはセキュリティマネージャからの制限を受けることになります。
<p><em>あるクラスが RMIClassLoader によってロードされると、そのクラスがそれ以後直接使用するクラスも RMIClassLoader によってロードされ、やはりセキュリティマネージャの管理を受けます。
</em><p>セキュリティマネージャが置かれていても、<code>java.rmi.server.useCodebaseOnly</code> プロパティを true に設定するとクラスをストリームに埋め込んだ URL から直列化されたオブジェクトによってダウンロードすることが出来なくなります（この場合でもローカルに定義された <code>java.rmi.server.codebase</code> からロードすることは可能です）。
<code>java.rmi.server.useCodebaseOnly</code> プロパティはクライアントとサーバ両方で指定できますが、アプレットに対しては適用できません。
<p>もし、アプリケーションが自分のセキュリティマネージャを定義し、それがクラスローダの作成を禁止した場合は、クラスはデフォルトの <code>Class.forName</code> メカニズムによってロードされます。
したがって、サーバは自身のポリシーをセキュリティマネージャとクラスローダを介して定義することができ、RMI システムはポリシーにしたがった動作をします。
<p><em>セキュリティマネジャーはすべて <code> java.lang.SecurityManager</code> abstract クラスから拡張されますが、このクラスはリソースの消費に関しては制約を課しません。したがって、現在の <code>RMISecurityManager</code> はロードされたクラスがリソースを間違って使用することについての予防策を持っていません。新しいセキュリティメカニズムが開発されましたので、RMI はこれを使うことになるでしょう。
</em><p><h1><a name="4018">
コンフィギュレーションシナリオ
</a></h1>RMI システムは多種類のシナリオをサポートしています。サーバはオープン、あるいはクローズ形式でコンフィギュレーションできます。アプレットはサーバ上でサポートされたオブジェクトのメソッドを呼び出すときに RMI を使うことができます。 
アプレットがリモートオブジェクトを作成して、これをサーバに渡す場合に、サーバはそのリモートオブジェクトに呼び出しバックするときに RMI を利用することができます。
Java アプリケーションは RMI をクライアント/サーバモードか、ピア・トゥ・ピアのどちらかで使用することができます。この章ではこれらのコンフィギュレーション問題に焦点をあてます。                                                                     <p><h2><a name="4033">
サーバ
</a></h2>典型的なクローズシステムシナリオでは、サーバはクラスをロードしないようにコンフィギュレーションされます。サーバが提供するサービスは、サーバマシンにローカルなリモートインタフェースによって定義されます。
サーバはセキュリティマネージャを持ちませんから、クライアントが URL を送ったとしてもサーバはクラスのローディングを行いません。
もし、サーバがスタブを持たないクラスのリモートオブジェクトを送ったとすると、メソッド呼び出しはそのリクエストが整列化される時点で失敗し、クライアントは例外を受け取ることになります。
<p>よりオープンなサーバシステムでは、サーバがエクスポートするリモートオブジェクトのクラスがクライアントによりロードされ、クライアントが提供するリモートオブジェクトが必要とする場合だけにクラスをロードするように <code>java.rmi.server.codebase</code> を定義します。 
サーバはセキュリティマネージャと RMI クラスローダの両方を持ち、これがサーバを保護します。さらに慎重にコンフィギュレーションしたい場合は、サーバは <code>java.rmi.server.useCodebaseOnly</code> プロパティを使って、クライアントが提供する URL からはクラスをロードできないようにします。
<p><h2><a name="4063">
アプレット
</a></h2>典型的には、必要なクラスは、アプレットが現れる HTML ページに埋め込まれた URL が参照している HTTP サーバか FPT サーバが提供します。アプレットが利用する RMI ベースのサービスは、アプレットはそれがダウンロードされたホストへのネットワーク接続しかできませんから、アプレットをダウンロードしたサーバ上になければなりません。

<p>例えば、通常のアプレットシナリオは HTML ページ、アプレットコード、RMI サービス、そしてブートストラップレジストリを提供する HTTP サーバのために単一のホストを使用します。
このシナリオでは、すべてのスタブ、スケルトン、そしてサポートクラスは HTTP サービスを使ってロードされます。
RMI サービスが提供してアプレットに渡される（そしてサーバに返されるかもしれない）すべてのリモートオブジェクトは RMI サービスがすでに知っているクラスのためのものです。
このケースでは、ネットワークからのクラスのローディングが起こりませんから RMI サービスの安全性は非常に高くなります。
<p><h2><a name="1564">
アプリケーション
</a></h2>アプレットとは異なり、Java 言語で記述されるアプリケーションでは任意のホストへの接続が可能です。したがって、アプリケーションの場合にはクラスのソースと RMI サービスが実行されている場所のコンフィギュレーションについてより多くのオプションを持ちます。
典型的な例では、リモートクラスを提供するのは単一の HTTP サーバに限定し、RMI ベースのアプリケーションについてはネットワーク上のサーバとユーザのデスクトップに分散させます。
<p>アプリケーションがローカルにロードされるときは、そのプログラムが直接使用するクラスもローカルに利用可能でなければなりません。
このシナリオではネットワーク上のソースからダウンロードされるのは、リモートインタフェースのクラス、スタブクラス、そしてリモートメソッド呼び出しで渡されるまたは返り値となる拡張クラスだけです。
<p>アプリケーションがローカルディレクトリからロードされずに、<a href="rmi-arch.doc.html#3933">クライアントのブートストラッピング</a>で説明されるメカニズムを使ってネットワークソースからロードされる場合には、アプリケーションが使用するすべてのクラスはやはり同じネットワークソースからダウンロードすることができます。

<p>ネットワークソースからのダウンロードを可能にするためには、各リモートオブジェクトサーバは、アプリケーションクラスと生成されたスタブ/スケルトンの所在を指定する <code>java.rmi.server.codebase</code>プロパティを使ってコンフィギュレーションされなければなりません。
codebase プロパティが指定されると、RMI システムはクラスの URL を直列化されたクラスの形式で埋め込みます。
<p>たとえ直列化されたオブジェクトのクラスがクラスをダウンロードできる URL で指定されたとしても、クラスやピアはクラスがローカルに利用可能である限りローカルにロードしようとします。

<p><h1><a name="4799">
プロキシ経由で RMI をファイアウオールを通して使う
</a></h1>RMI のトランスポート層は通常 Internet 上のホストへ直接ソケットを開こうとします。
しかし、多くの Intranet はファイアウオールを備えているためこれができません。
このため、デフォルト RMI トランスポートはこれにかわる2種類の HTTP ベースのメカニズムを備えて、ファイアウオールの後ろにいるクライアントがファイアウオールの彼方にあるリモートオブジェクト上のメソッドを呼び出せるようにしています。
<p><h2><a name="3750">
RMI 呼び出しは HTTP プロトコルの中でどのようにパッケージされるか
</a></h2>ファイアウオールの彼方に到達できるように、トランスポート層は firewall-trusted HTTP プロトコルに RMI 呼び出しを埋め込んでおきます。
RMI 呼び出しのデータは HTTP POST リクエストの本体として外へ送り出され、返される情報も HTTP による応答本体の一部として組み込まれています。トランスポート層は POST リクエストを次の2つのいずれかの方法で形式を整えます。
<p><ol>
<li>ホストマシンの任意のポートに向けられた HTTP リクエストをファイアウオールプロキシが転送する場合に、そのリクエストは RMI サーバが受信しているポートへ直接転送されます。
サーバマシン上のデフォルトの RMI トランスポート層は、POST リクエストの中の RMI 呼び出しを理解してデコードできるサーバソケットを使って受信しています。
<li>ファイアウオールプロキシが HTTP リクエストを良く知られた HTTP ポートにのみ転送する場合には、そのリクエストはホストマシン上のポート番号 80 で受信しているサーバへ転送され、CGI スクリプトが実行されてその呼び出しを同じマシン上のターゲット RMI サーバのポートへ転送します。
</ol>
<h2><a name="3754">
デフォルトソケットファクトリ
</a></h2>RMI のトランスポートは <code>java.rmi.server.RMISocketFactory</code> クラスを拡張して、クライアントとサーバソケットへのリソースプロバイダとなるソケットファクトリのデフォルト実装を提供しようとします。
このデフォルトソケットファクトリは、次に説明する方法でファイアウオールを透明に通り抜けるメカニズムを備えたソケットを作り出します。
<p><ul><li>クライアントのソケットは自動的に、ソケットでは直接コンタクトできないホストへの HTTP 接続を試みる。
<li>サーバソケットは新規に受け付けられた接続が HTTP の POST リクエストであるかを自動的に検出して、もしそうならば、リクエストの本体のみを見せるソケットをトランスポートに返し、その出力を HTTP による応答の形式に整える。
</ul>このようなデフォルト動作をするクライアント側ソケットはファクトリの <code>java.rmi.server.RMISocketFactory.createSocket</code> メソッドが提供します。
このようなデフォルト動作をするサーバ側のソケットはファクトリの <code>java.rmi.server.RMISocketFactory.createServerSocket</code> メソッドが提供します。
<p><h2><a name="3759">
クライアントのコンフィギュレーション
</a></h2>クライアント側ではファイアウオールを通り抜けて RMI 呼び出しを送るための特別なコンフィギュレーションは必要ありません。
<p>しかし、クライアントは <code>java.rmi.server.disableHttp</code> プロパティのブール値を true に設定して RMI 呼び出しを HTTP リクエストの形式にパッケージするのを禁止させることができます。
<p><h2><a name="3762">
サーバのコンフィギュレーション
</a></h2><em>ホスト名はホストの IP アドレスとして指定されてはなりません。ファイアウオールプロキシの中にはそのような形式のホスト名を転送しないものがあるからです。
</em><p><ol>
<li>サーバホストのドメインの外にあるクライアントがあるサーバのリモートオブジェクトを呼び出せるためには、クライアントはまずそのサーバを見つけ出せなければなりません。このためには、サーバがエクスポートするリモート参照がそのサーバの完全修飾名を含んでいなければなりません。
<a name="3764">
サーバのプラットフォームとネットワーク環境によっては、サーバが実行中の Java 仮想マシンがこのような情報を利用できない場合があります。利用できないときは、ホストの完全修飾された名前はサーバがスタートする時点で <code>java.rmi.server.hostname</code> プロパティとして指定されていなければなりません。
<p>
</a><a name="3765">
例えば、次のコマンドでマシン chatsubo.javasoft.com 上の RMI サーバクラス <code>ServerImpl</code> をスタートさせることができます。
<p>
</a><dl><a name="3766"><pre>   java -Djava.rmi.server.hostname=chatsubo.javasoft.com ServerImpl
</pre></a></dl><li>もしサーバが、ファイアウオールの彼方にある、任意のポートへ転送できる RMI クライアントをサポートしないならば、次のコンフィギュレーションを使うことができます。
<ol>
<li>HTTP サーバはポート番号 80 を受信用に使用する。
<li>CGI スクリプトをエイリアスURLパス <code>/cgi-bin/java-rmi</code> に置きます。このスクリプトは、
<ul>
<li>ローカルな Java インタープリターを呼び出して、トランスポート層の中にあるクラスを実行してリクエストを適切に呼び出して RMI サーバポートへ転送する。
<li>Java 仮想マシンのプロパティを CGI 1.0 で定義される環境変数と同じ名前と値で定義する。
<a name="3773">
スクリプトの例は Solaris と Windows 32 オペレーションシステムの RMI ディストリビューションに含まれる。スクリプトはサーバマシン上の Java インタープリターへの完全なパスを指定することに注意すること。
<p>
</a></ul>
</ol>
</ol>
<h2><a name="3774">
機能上の問題と制限
</a></h2>HTTP リクエストを介して送信された呼び出しは、プロキシによる転送の時間遅れを除いたとしても、直接ソケットを介した場合よりもはるかに遅くなります。
<p>ファイアウオールを通す場合、HTTP リクエストは一方向でのみ開始できるため、クライアントは自分のリモートオブジェクトをファイアウオールの外へエクスポートすることはできません。これはファイアウオールの外にあるホストが内側にあるクライアントのメソッド呼び出しを開始できないためです。
<p>
<hr><br>
 
<a href="rmiTOC.doc.html">目次</a> <a href="rmi-objmodel.doc.html">前項目</a> <a href="rmi-client.doc.html">次項目</a>
<hr><br>
 


<address>
<a href="mailto:"></a>
</address>

<i>Copyright (C) 1996, 1997 Sun Microsystems, Inc.  All rights
reserved.</i>

<!-- This file was created with Quadralay WebWorks Publisher 3.0.4 -->
<!-- -->
<!-- For more information on how this document, and how the rest of -->
<!-- this server was created, email  -->
<!-- -->
<!-- Last updated: 03/18/97 12:59:40 -->

</body>
</html>
