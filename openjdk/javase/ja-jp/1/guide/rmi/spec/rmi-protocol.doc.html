<html><head><title>RMI ワイヤプロトコル
</title></head>
<body bgcolor=#ffffff>
 
<a href="rmiTOC.doc.html">目次</a> <a href="rmi-dgc.doc.html">前項目</a> <a href="rmi-exceptions.doc.html">次項目</a>
<hr><br>
 
<a name="60">
<h1>RMI ワイヤプロトコル
</h1>
</a>
<hr><p><a name="64">

<p>
</a><h1><a name="3243">
概要
</a></h1>RMI プロトコルは on-the-wire 形式のために他に2つのプロトコルを利用します。
Java オブジェクト直列化と HTTP です。オブジェクト直列化プロトコルは呼び出しと返り値の一体化（ストリーム化）に使用します。HTTP プロトコルはリモートメソッド呼び出しを "POST" し、かつ条件が許すならば返り値を取得するために使用します。
それぞれのプロトコルは別々の文法としてドキュメントが存在します。生成規則の非ターミナルシンボルは別のプロトコルの制御規則を参照します。(オブジェクト直列化または HTTP) 
プロトコルの境界を越える場合は、それ以後の生成規則はエンベッドされたプロトコルを使用します。 
<p><h3><a name="3245">
文法表記についての注意
</a></h3><ul><li>ここでは Java 言語仕様（Java Language Specification）で使用されているのと類似の表記を使います。（JLS の第2,3章参照）
<li>ストリームの制御コードはヘキサデシマルのリテラル値で表現します。
<li>文法上の非ターミナルシンボルは、メソッド呼び出しで与えられるアプリケーションに特有な値であることを表します。このような非ターミナルの定義は Java のデータ型から構成されます。それぞれの非ターミナルからそれぞれの型へのテーブルマッピングは文法規則に従います。
</ul><h1><a name="3249">
RMI トランスポートプロトコル
</a></h1>	RMI のワイヤ形式は <em>Stream</em> で表現されます。ここで採用している用語はクライアントからの観点を反映させたものです。<em>Out</em> は出力メッセージの参照を表し、<em>In</em> は入力メッセージの参照を表します。トランスポートヘッダの内容はオブジェクト直列化のフォーマットは行われ<em>ません</em>。 
<p><dl><pre><em>Stream:
	Out
	In
</em></pre></dl>RMI の入力と出力ストリームは対になっています。 各 <em>Out</em> ストリームは対応する <em>In</em> ストリームを持ちます。<em>Out</em> ストリームは文法的にはソケットの出力ストリームにマップします（クライアントの観点からは） <em>In</em> ストリームは (文法的には) は対応するソケットの入力ストリームと対を成します。出力と入力ストリームは対を作りますから、ヘッダー情報の中で入力ストリームで必要とするのはプロトコルを認識できたかどうかのアクノレッジのみです。それ以外のヘッダー情報（マジックナンバーやバージョン番号）はストリーム対のコンテキストで暗黙の了解が可能です。
<p><h2><a name="3252">
出力ストリームの形式
</a></h2>RMI における出力ストリームは、トランスポート <em>Header</em> 情報とそれに続く<em>Messages</em> の並びから構成されます。 出力ストリームは HTTP プロトコルに呼び出しを埋め込んだものともいえます。
<p><dl><pre><em>Out:
	Header Messages
	HttpMessage
</em></pre><pre><em>Header</em>:
	<code>0x4a 0x52 0x4d 0x49</code> <em>Version Protocol</em>
</pre><pre><em>Version</em>:
	<code>0x00 0x01
</code></pre><pre><em>Protocol:
	StreamProtocol
	SingleOpProtocol
	MultiplexProtocol
</em></pre><pre><em>StreamProtocol</em>:
	<code>0x4b
</code></pre><pre><em>SingleOpProtocol</em>:
	<code>0x4c
</code></pre><pre><em>MultiplexProtocol</em>:
	<code>0x4d
</code></pre><pre><em>Messages:
	Message
	Messages Message
</em></pre></dl><em>メッセージ</em> は特定のプロトコル内で、 <em>Protocol</em> が指定する方法にしたがってラップされます。 
<em>SingleOpProtocol</em> の場合は、<em>Header</em> に続く <em>Message</em> が一つしか無い場合があり、 <em>Message</em> の中にラップされるべき追加データが存在しないことがあります。<em>SingleOpProtocol</em> が使われるのは HTTP リクエストの中に呼び出しが埋め込まれるときであり、単一のリクエストと応答以上の相互作用はできません。
<p><em>StreamProtocol</em> と <em>MultiplexProtocol</em> の場合は、サーバはバイトコード <code>0x4e</code> で応答してプロトコルをサポートすることを知らせなければならず、そしてホスト名とポート番号を含んだ <em>EndpointIdentifier</em> で応答することによりサーバから見えるところは現在クライアントが使用中であることを知らせます。 
クライアントはこの情報を用いて、セキュリティ上の理由でできない場合もありますが、自分のホスト名を知ることができます。 
クライアントはその後、もう一個の <em>EndpointIdentifier</em> で応答する必要があり、応答の中には接続を受け付けるときのデフォルトの終点が含まれます。
<em>MultiplexProtocol</em> では、サーバはこの情報からクライアントを特定することが可能です。
<p><em>StreamProtocol</em> の場合は、エンドポイントのネゴシエーションの後に、 <em>Messages</em> がそれ以上のラッピングを行うことなしに出力ストリームへ送られます。 
<em>MultiplexProtocol</em> の場合は、 <a href="rmi-protocol.doc.html#3477">RMI の多重プロトコル</a>で解説されているようにソケット接続が多重化接続の具体的な接続として使用されます。
この多重化された接続上で開始された仮想接続は、次に説明される一連の <em>Messages</em> から構成されます。
<p>出力タイプには、<em>Call</em>, <em>Ping</em> そして <em>DgcAck</em> の3つのタイプがあります。 
<em>Call</em> はメソッド呼び出しをエンコードします。 
<em>Ping</em> はトランスポートレベルのメッセージでありリモート仮想マシンが繋がっているかをテストします。 
<em>DGCAck</em> はサーバの分散ガベージコレクタへ向けられたメッセージであり、サーバからの返り値に含まれるリモートオブジェクトがクライアントによって受け取られたことを示すアクノレッジ信号です。
<p><dl><pre><em>Message:
	Call
	Ping
	DgcAck
</em></pre><pre><em>Call</em>:
	<code>0x50</code> CallData
</pre><pre><em>Ping</em>:
	<code>0x52
</code></pre><pre><em>DgcAck</em>:
	<code>0x54</code> <em>UniqueIdentifier	
</em></pre></dl><h2><a name="3263">
入力ストリームの形式
</a></h2>現在入力メッセージには3つのタイプがあり、それぞれ <em>ReturnData</em>, <em>HttpReturn</em> そして <em>PingAck</em> の3種類です。
<em>ReturnData</em> は「通常の」RMI コールの結果です。 
<em>HttpReturn</em> は HTTP プロトコルに埋め込まれた呼び出しに対する返り値です。 
A <em>PingAck</em> は <em>Ping</em> メッセージに対するアクノレッジ応答です。
<p><dl><pre><em>In:
	ProtocolAck Returns
	ProtocolNotSupported
	HttpReturn
</em></pre><pre><em>ProtocolAck</em>:
	<code>0x4e</code>
</pre><pre><em>ProtocolNotSupported</em>:
	<code>0x4f
</code></pre><pre><em>Returns:
	Return
	Returns Return
</em></pre><pre><em>Return:
	ReturnData
	PingAck
</em></pre><pre><em>ReturnData</em>:
	<code>0x51</code> <em>ReturnValue<sub>opt
</sub></em></pre><pre><em>PingAck</em>:
	<code>0x53
</code></pre></dl><h1><a name="3270">
RMI におけるオブジェクト直列化プロトコルの使用
</a></h1>RMI コールにおけるコールとリターンのデータは Java オブジェクト直列化プロトコルに従って整形されます。それぞれのメソッド呼び出しの <em>CallData</em> は <em>ObjectIdentifier</em> (コールの対象)、<em>Operation</em> (呼び出されるメソッドを表す数値)、<em>Hash</em> (クライアントスタブとリモートオブジェクトが共通なスタブプロトコルを使うことを確認する数値)、そしてそれに続く<em>Arguments</em>（無くてもよい）によって表現されます。 
<p><dl><pre><em>CallData:
	ObjectIdentifier Operation Hash Arguments<sub>opt
</sub></em></pre><pre><em>ObjectIdentifier:
	ObjectNumber UniqueIdentifier
</em></pre><pre><em>UniqueIdentifier:
	Number Time Count
</em></pre><pre><em>Arguments:
	Value
	Arguments Value
</em></pre><pre><em>Value:
	Object
	Primitive
</em></pre></dl>RMI コールの <em>ReturnValue</em> はコールが正常終了したか例外を発生したかを示すリターンコード、リターン値にタグ付けする <em>UniqueIdentifier</em> (必要ならば DGCAck を送るために使用)、そしてこれに返り値 <em>Value</em> またはスローされた <em>Exception</em> が続きます。
<p><dl><pre><em>ReturnValue</em>:
	<code>0x01</code> <em>UniqueIdentifier Value</em>
	<code>0x02</code> <em>UniqueIdentifier Exception</em>
</pre></dl>デフォルトの直列化では <em>ObjectIdentifier</em>, <em>UniqueIdentifier, </em>と<em> EndpointIdentifier </em>は書き出されず、それぞれが自分自身の <code>write</code> メソッドを使います。(これはオブジェクト直列化が使う <code>writeObject</code> ではありません); それぞれのタイプの識別子の <code>write</code> メソッドはそれぞれのコンポーネントデータを順次出力ストリームへ追加します。
<p><h1><a name="3278">
RMI における HTTP POST プロトコル
</a></h1>リモートメソッドをファイアウオールを通して呼び出しを行うために、RMI コールの幾つかは HTTP プロトコル、より具体的には HTTP POST を使用します。
ポストヘッダーで指定される URL は次のいずれかです。
<p><dl><pre>	<code>http://</code><em>&lt;host&gt;<code>:</code>&lt;port&gt;<code></em>/ 
</code>	<code>http://</code><em>&lt;host&gt;</em><code>:80/cgi-bin/java-rmi?forward=</code><em>&lt;port&gt;</em>
</em></pre></dl>最初の URL は特定の <em>host</em> と<em>port</em> 上の RMI サーバと直接通信するために使われます。第二の URL 形式はサーバ上の "cgi" スクリプトが呼び出しを特定の <em>port</em> 上のサーバへ転送するために使用されます。
<p><em>HttpPostHeader</em> は POST リクエストのための標準 HTTP ヘッダーです。
<em>HttpResponseHeader</em> はポストへの標準 HTTP 応答です。応答のステータタスが200以外の場合は、<em>Return</em> が無いと判断されます。HTTP POST リクエストに埋め込まれる RMI コールは一つだけであることに注意してください。
<p><dl><pre><em>HttpMessage:
	HttpPostHeader Header Message
</em></pre><pre><em>HttpReturn:
	HttpResponseHeader Return
</em></pre></dl><em><em>SingleOpProtocol</em> だけが <em>HttpMessage</em> の <em>Header</em> に現れます。
HttpReturn はプロトコルのアクノレッジバイトを含みません。
</em><p><h1><a name="3474">
RMI のアプリケーション固有の値
</a></h1>次の表は RMI で用いられるアプリケーション固有の値を表現する非ターミナルシンボルを列挙したものです。表はそれぞれのシンボルをそれぞれの持つ型に対応させています。各シンボルはそれが埋め込まれるプロトコルを使って整形されます。
<p><dl>
<pre>
<em>Count</em>			<code>short</code>
<em>Exception</em>		<code>java.lang.Exception</code>
<em>Hash</em>			<code>long</code>
<em>Hostname</em>		<code>String</code>
<em>Number</em>			<code>int</code>
<em>Object</em>			<code>java.lang.Object</code>
<em>ObjectNumber</em>		<code>int</code>
<em>Operation</em>		<code>int</code>
<em>PortNumber</em>		<code>int</code>
<em>Primitive</em>		<code>byte, int, short, long...</code>
<em>Time</em>			<code>long</code>
</pre>
</dl><h1><a name="3477">
RMI の多重プロトコル
</a></h1>多重化の目的は、エンドポイントの一方だけが他の機能（例えば TCP 接続）を使って双方の接続を開くことができる環境に対して、2つのエンドポイントがそれぞれ相互に他端に対して多重の全二重接続を開くことができるモデルを提供することにあります。RMI はこの単純な多重化プロトコルを使って他の方法ではできない状況においても、クライアントが RMI サーバオブジェクトに接続するのを可能にします。
例えば、アプレット環境のセキュリティマネージャの中には、入ってくる接続を受信するためのサーバソケットの作成を禁止して、アプレットが RMI オブジェクトをエクスポートして直接ソケット接続からのリモートコールへのサービスすることををできないようにしています。
もしアプレット codebase ホストに対して通常のソケット接続を<em>できる</em>ならば、その接続上で多重プロトコルを使い codebase ホストが、アプレットによりエクスポートされた RMI オブジェクトのメソッドを呼び出すことができます。
この章では多重プロトコルの形式と規則を説明します。
<p><h2><a name="3553">
定義
</a></h2>この章では以後のプロトコルの説明で使用される用語を定義します。

<p><em>エンドポイント</em> とは多重プロトコルを使って接続されているユーザの一方を指します。
<p>多重プロトコルはすでに存在する双方向の信頼できるバイトストリームの上位層になり、このバイトストリームはエンドポイントの片側が他方に対して開いたものです。現行の RMI の使用法ではこれは常に java.net.Socket オブジェクトを使って作られた TCP 接続です。この接続のことを<em>具体的接続</em>と呼びます。
<p>多重プロトコルでは<em>仮想接続</em>機能を使うことができ、この接続は双方向の信頼できるバイトストリームであり、2つのエンドポイント間の特定のセッションを表現するものです。
2つのエンドポイント間の一つの具体的接続上の仮想接続のセットが<em>多重接続</em>を構成します。 
多重プロトコルを使い、どちらのエンドポイントからも仮想接続のオープンとクローズが可能です。
仮想接続のあるエンドポイントに対しての状態は、具体的接続上でやり取りされる多重プロトコルの要素により定義されます。
この状態は接続のオープン、クローズに関連し、行き来する実際のデータと関連したフローコントロールを含みます。
特別ほかの説明が付加されなければ、<em>接続</em>という用語はこの章の以後の部分では <em>仮想接続</em>の意味で用いられます。
<p>ある多重接続の中の仮想接続は16ビット整数で特定され、これを <em>接続識別子</em>と呼びます。したがって、一つの多重接続上には最大65,536の仮想接続が存在することになります。同時に使用できる仮想接続の数は実装によって制限されることがあります。
<p><h2><a name="3713">
接続状態とフローコントロール
</a></h2>接続は種々の多重プロトコルにより定義された <em>オペレーション</em> により操作されます。 
プロトコルで定義されたオペレーションには次の名前のものがあります： OPEN, CLOSE, CLOSEACK, REQUEST, そして TRANSMIT。
全てのオペレーションに関する正確な形式と規則の詳細は<a href="rmi-protocol.doc.html#3494">プロトコルの形式</a>に説明されています。
<p>OPEN, CLOSE, そして CLOSEACK オペレーションは接続の開いたり閉じたりし、REQUEST と TRANSMIT オペレーションは開いた接続上でフローコントロールメカニズムの制限下でのデータ伝送に使われます。
<p><h3><a name="3917">
接続状態
</a></h3>仮想接続はエンドポイントが OPEN オペレーションをその接続に対して送り、その接続に対する OPEN オペレーションを受け取ると（そしてその後でクローズされていないならば）、その特定のエンドポイントに対して <em>オープン</em>した状態になります。 
種々のオペレーションを次に説明します。
<p>仮想接続はエンドポイントが接続に CLOSE オペレーションを送ったが、まだそれに続く CLOSE または CLOSEACK を受け取っていないときにそのエンドポイントに対して <em>ペンディングクローズ</em>の状態にあります。
<p>仮想接続は開かれなかったとき、あるいは CLOSE や CLOSEACK オペレーションを受け取ったときに（そしてそれ以後オープンされていないならば）、その特定のエンドポイントに対して <em>クローズ</em>の状態にあります。
<p><h3><a name="3921">
フローコントロール
</a></h3>多重プロトコルは一つの具体的接続上に平行して複数の仮想接続が存在できるように単純パケットフローコントロールメカニズムを使用します。フローコントロールメカニズムに要求される高レベルでの要求は、仮想接続の状態は独立であることです。つまり、一つの接続の状態は他の接続にたいして影響を及ぼしません。 
例えば、接続に入ってくるデータを扱うバッファがフルになったとしても、これが他の接続のデータ伝送とかデータ処理を何ら妨げません。このことは一つの接続の進行状態は他の接続が終了してしまっても影響を受けないという特性実現のために重要です。RMI の再帰的なコールでは実際にこれが起こります。したがって、実際問題としては、接続の実装は常にいかなる時でも多重プロトコルデータ（プロトコル仕様を満たしていると仮定して）が具体的接続上に入ってくるのに備えている能力がなければなりません。
<p>各エンドポイントはそれぞれの接続に関して2つの状態値を持ちます。 エンドポイントが何バイトのデータを要求し、そのうちの何バイトがまだ受け取っていないかを示す (<em>入力要求カウント</em>) と、もう一方のエンドポイントが何バイトのデータを要求し、その中でこちらのエンドポイントが何バイトを残しているかを示す (<em>出力要求カウント</em>) です。
<p>一つのエンドポイントの出力要求カウントはもう一方のエンドポイントから REQUEST オペレーションを受けるたびに増加し、TRANSMIT オペレーションを送ると減少します。 
一つのエンドポイントの入力要求カウントはそれが REQUEST オペレーションを送ると増加し、TRANSMIT オペレーションを受信すると減少します。どちらかの数値がマイナスになるとプロトコル違反です。
<p>一つのエンドポイントが、ブロッキングの発生なしに現在扱えるバイト数の範囲を超えてて REQUEST オペレーションを送り入力要求カウントを限界を超えて増加させてしまうのはプロトコル違反になります。
しかし、接続されているユーザがデータを待っている状態では、入力要求カウントは確実にゼロ以上の値でなければなりません。
一つのエンドポイントが出力要求カウントを超えた TRANSMIT オペレーションを送るのはプロトコル違反です。
送出されるデータが、その接続のユーザが陽にフラッシュを要求するまで、バッファリングされていることがあります。
フラッシュ要求または、実装の出力バッファフルのためにデータが接続上に送出されるときは、接続上のユーザは十分に TRANSMIT オペレーションが進行するまでブロックされることがあります。
<p>ここで概説した以外では、実装は適切と判断される範囲内で自由に REQUEST や TRANSMIT オペレーションを実行することが出来ます。例えば、エンドポイントは自分の受信バッファが空でなかったとしても接続にたいして追加データを要求することができます。
<p><h2><a name="3494">
プロトコルの形式
</a></h2>多重プロトコルのバイトストリーム形式は、可変長レコードが隣接して繋がったものです。レコードの最初のバイトはオペレーションコードであり、そのレコードに対するオペレーションを明らかにし、それ以後の内容の形式を決定します。許されるオペレーションコードは次のとおりです。
<p>
<pre>
	Value		Name
	-----		----

	0xE1		OPEN
	0xE2		CLOSE
	0xE3		CLOSEACK
	0xE4		REQUEST
	0xE5		TRANSMIT
</pre>
<p>レコードの最初のバイトが上に定義されたオペレーションコード以外のときはプロトコル違反になります。 次の章でそれぞれのオペレーションコードに対するレコード形式を説明します。
<p><h3><a name="3498">
OPEN オペレーション
</a></h3>OPEN オペレーションの形式:
<p>
<pre>
	size (bytes)		Name		Description
	------------		----		-----------

	1			<em>opcode</em>		オペレーションコード (OPEN)
	2			<em>ID</em>		接続識別子
</pre>
<p>エンドポイントは OPEN オペレーションを送って指定された接続を開きます。 
もし <em>ID</em> が指示する接続がすでにオープンしていたり、送り側のエンドポイントに対してペンディングクローズの状態でこのこのコマンドを送るのはプロトコル違反です。
接続が開かれた状態では両側のエンドポイントでの入力と出力の要求カウントの状態は共にゼロになっています。
<p>OPEN オペレーションの受信は他端のエンドポイントが指定の接続を開こうとしていることを示します。接続がオープンした状態では両側のエンドポイントでの入力と出力の要求カウントの状態は共にゼロになっています。
<p>両側のエンドポイントでの識別子の衝突を防止するために、有効接続識別子のためのスペースは MSB (Most significat bit) の値によって2分されていてます。
それぞれのエンドポイントは高位ビットが特定の値を持っているときだけ接続を開くことが許されます。
具体的接続を開始しようとするエンドポイントは最高位ビットがセット (1）された識別子でのみ接続を開くことができ、他端のエンドポイントは最高位ビットがゼロに設定された識別子で接続を開かなければなりません。 
例えば、サーバソケットを作成できない RMI アプレットが自分の codebase ホストに対して多重接続を開始しようとするときは、アプレットは仮想接続を識別子 0x8000-7FFF の範囲で開くことができ、サーバは識別子の範囲 0-0x7FFF の範囲で仮想接続を開くことができます。
<p><h3><a name="3503">
CLOSE オペレーション
</a></h3>CLOSE オペレーションの形式:
<p>
<pre>
	Size (bytes)		Name		Description
	------------		----		-----------

	1			<em>opcode</em>		オペレーションコード (OPEN)
	2			<em>ID</em>		接続識別子
</pre>
<p>エンドポイントは CLOSE オペレーションを送って指定の接続を閉じます。 
もし、<em>ID</em> が指示する接続が現在閉じていたり、送信側に対してペンディングクローズになっているとプロトコル違反になります（もしこの接続に対して CLOSE オペレーションを送っていると受信側に対してペンディングクローズになっているかもしれません）。 
CLOSE を送ると、その接続は送信側のエンドポイントに対してペンディングクローズ状態になります。従って、接続の他端から CLOSE または CLOSEACK を受け取ってからでないと再度接続を開くことはできません。
<p>CLOSE オペレーションの受信は接続の他端がその接続を閉じたことを意味し、受信側にとっても接続は閉じられます。 
受信側エンドポイントはこの接続に対してこれ以上の（再度オープンされない限り）オペレーションを行う必要はありませんが、実装の入力バッファにたまっているデータは接続のユーザへ渡さなければなりません。 
もし接続がペンディングクローズではなく前もってオープンされているならば、受信側エンドポイントはその接続に対して CLOSEACK で応答する必要があります。
<p><h3><a name="3510">
 CLOSEACK オペレーション
</a></h3>CLOSEACK オペレーションのレコード形式:
<p>
<pre>
	size (bytes)		Name		Description
	------------		----		-----------

	1			<em>opcode</em>		オペレーションコード (OPEN)
	2			<em>ID</em>		接続識別子
</pre>

<p>エンドポイントは受信側エンドポイントからの CLOSE を認識したことを知らせるために CLOSEACK オペレーションを送ります。
もし ID が指定する接続の受信側が、このオペレーションを受信したときにペンディングクローズの状態になっていない場合はプロトコル違反になります。
<p>CLOSEACK オペレーションの受信は、その接続がペンディングクローズからクローズへ状態変化したことを示します。したがって、これ以後はその接続を再オープンすることができます。
<p><h3><a name="3514">
REQUEST オペレーション
</a></h3>REQUEST オペレーションのレコード形式:
<pre>
	size (bytes)		Name		Description
	------------		----		-----------

	1			<em>opcode</em>		オペレーションコード (OPEN)
	2			<em>ID</em>		接続識別子
	4			<em>count</em>		要求されたバイト数
</pre>

<p>エンドポイントは REQUEST オペレーションを送ってその接続の入力要求カウントを増加させます。 
もし、<em>ID</em> が指定する接続が送信側のエンドポイントから見てオープンされていなければプロトコル違反になります。
エンドポイントの入力要求カウントは <em>count</em>が示す値だけ増加します。
<em>count</em> は符号付きの 32 bit 整数であり、もしこの値がゼロまたはマイナスになるのはプロトコル違反です。
<p>REQUEST オペレーションの受信はその接続の出力要求カウントを <em>count</em>だけ増加させます。 
もし受信側にとってその接続がペンディングクローズ状態であるときは、いかなる REQUEST オペレーションも無視されます。
<p><h3><a name="3520">
TRANSMIT オペレーション
</a></h3>TRANSMIT オペレーションのレコード形式
<p>
<pre>
	size (bytes)		Name		Description
	------------		----		-----------

	1			<em>opcode</em>		オペレーションコード (OPEN)
	2			<em>ID</em>		接続識別子
	4			<em>count</em>		伝送バイト数
	<em>count			data</em>		伝送データ
</pre>
<p>エンドポイントは TRANSMIT オペレーションにより指定の接続を介して実際のデータ伝送を行います。
もし、指定した接続が送信側のエンドポイントから見てクローズされているときはプロトコル違反になります。
エンドポイントの出力要求カウントは <em>count</em>の値だけ減少します。 
<em>count</em> は符号付きの 32 bit 整数であり、送信側の値が TRANSMIT オペレーションによってゼロまたは負の値になるのはプロトコル違反です。

<p>TRANSMIT オペレーションの受信は count バイトのデータがキューに追加され、接続から読める状態になったことを示します。受信側エンドポイントの入力要求カウントは <em>count</em>分だけ減少します。
もし、この結果入力要求カウントがゼロになり、かつ接続のユーザが更にデータを読む必要があるときは、エンドポイントは追加の REQUEST オペレーションで応答しなければなりません。
もし接続が受信側のエンドポイントから見てペンディングクローズならば、いかなる TRANSMIT オペレーションも無視されます。
<p><h3><a name="3743">
プロトコル違反
</a></h3>上に説明したプロトコル違反が発生したとき、または具体的接続で通信エラーが発生したときは多重接続は <em>shut 
down</em> されます。実際の接続は終了し、全ての仮想接続も即時に閉じられます。仮想接続上ですでに読み込み可能になっていたデータは接続のユーザによって読みとり可能です。
<p>
<hr><br>
 
<a href="rmiTOC.doc.html">目次</a> <a href="rmi-dgc.doc.html">前項目</a> <a href="rmi-exceptions.doc.html">次項目</a>
<hr><br>
 


<address>
<a href="mailto:"></a>
</address>

<i>Copyright (C) 1996, 1997 Sun Microsystems, Inc.  All rights
reserved.</i>

<!-- This file was created with Quadralay WebWorks Publisher 3.0.4 -->
<!-- -->
<!-- For more information on how this document, and how the rest of -->
<!-- this server was created, email  -->
<!-- -->
<!-- Last updated: 03/18/97 13:00:08 -->

</body>
</html>


