<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc1.html">前項目</a> | <a href="innerclasses.doc3.html">次項目</a> 
</td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="19784"></a>
<h1>内部クラスはどのように機能するのか？</h1>
<a name="14472"></a>
内部クラスコードは通常それを囲む親クラスのインスタンスに関連して定義されるので、内部クラスインスタンスは親インスタンスを決定できる必要があります。<p><a name="14829"></a>
JavaSoft Java 1.1 コンパイラは、内部クラスを親クラスにリンクする付加的な <code>private</code> インスタンス変数を追加して、これを調整します。この変数は内部クラス構築子に渡されてくる付加的な引数から初期化されます。代わりにこの引数は、内部クラスインスタンスを作成する式によって決定されます; デフォルトでは、作成を行うオブジェクトになります。<p><a name="14838"></a>
Java 1.1 言語仕様では、クラスメンバである型の名前は、Java virtual machine バイトコードを生成する目的で Java 1.0 コードに変換されたとき、内部クラスの完全修飾名から構成されると指定しています。ただし、クラス名に続く各々の`<code>.</code>'文字は`<code>$</code>'で置き換えられるという点を除きます。さらに、各内部クラス構築子は、前に追加された引数の親インスタンスを受け取ります。次に、<code>FixedStack</code> の変換済ソースコードの例を示します: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="10037"></a>public class FixedStack {
    <a name="10042"></a>    ... <em>(the methods omitted here are unchanged</em>)
    <a name="10057"></a>    public java.util.Enumeration elements() {
    <a name="10058"></a>        return new FixedStack$Enumerator(this);
    <a name="10059"></a>    }
    <a name="10060"></a>}
    <a name="10061"></a>
    <a name="14889"></a>class FixedStack$Enumerator implements java.util.Enumeration {
    <a name="14890"></a>    private FixedStack this$0; // saved copy of FixedStack.this
    <a name="14891"></a>    FixedStack$Enumerator(FixedStack this$0) {
    <a name="10065"></a>        this.this$0 = this$0;
    <a name="10066"></a>        this.count = this$0.top;
    <a name="10067"></a>    }
    <a name="14908"></a>
    <a name="10069"></a>    int count;
    <a name="10071"></a>    public boolean hasMoreElements() {
    <a name="10072"></a>        return count &gt; 0;
    <a name="10073"></a>    }
    <a name="10075"></a>    public Object nextElement() {
    <a name="10076"></a>        if (count == 0)
    <a name="10077"></a>            throw new NoSuchElementException("FixedStack");
    <a name="10078"></a>        return this$0.array[--count];
    <a name="10079"></a>    }
    <a name="10080"></a>}
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p><a name="14905"></a>
既に Java または C++ アダプタクラスでプログラムを組んだことのある人は、これに似たコードを書いたことがあるはずです。異なる点は、リンク変数は手作業で定義し、トップレベルアダプタクラスの中で明示的に初期化する必要があることで、Java 1.1 コンパイラはこれらを内部クラス用に自動的に作成します。<p><a name="15008"></a>
<code>Enumerator</code> が、親インスタンスの <code>top</code> または <code>array</code> フィールドを参照する必要のある時、これは <code>this$0</code> と呼ばれる <code>private</code> リンクを経由して行います。この名前のスペリングは内部クラスの Java 1.0 言語への変換の必須部分で、デバッガおよび同様のツールはこのようなリンクを簡単に認識できます。(ほとんどのプログラマは幸いにもこのような名前に気が付いていません。)<p><a name="20612"></a>
(注:  Java 1.1 のいくつかの実装には制限があり、<code>this$0</code> の初期化は、すべてのスーパークラス構築子が実行されるまで遅延されます。これは、サブクラスメソッドが行う上位レベル参照は、スーパークラス構築子がそのメソッドをたまたま実行した場合に、失敗することを意味します。)<p><a name="20614"></a>
<h2>		 ローカル変数の参照</h2>
<a name="18060"></a>
ブロックに対してローカルなクラス定義は、ローカル変数にアクセスする可能性があります。このことはコンパイラのジョブを複雑にします。ローカルクラスの以前の例を次に示します: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="18063"></a>    Enumeration myEnumerate(final Object array[]) {
    <a name="18065"></a>        class E implements Enumeration {
    <a name="19823"></a>            int count = 0;
    <a name="18066"></a>            public boolean hasMoreElements()
    <a name="18067"></a>                { return count &lt; array.length; }
    <a name="18068"></a>            public Object nextElement() {
    <a name="18069"></a>                { return array[count++]; }
    <a name="18070"></a>        }
    <a name="18071"></a>        return new E();
    <a name="18072"></a>    }
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p><a name="10536"></a>
ローカル変数を内部クラスのメソッドに可視にするために、コンパイラは変数の値を内部クラスがアクセスできる場所にコピーする必要があります。同じ変数を参照する場合、同じ値があらゆる場所で作られ、名前がそのスコープのすべての部分で同じ変数を参照するために一貫して表示される限り、異なる場所で異なるコード順番を使用する可能性があります。<p><a name="14964"></a>
規則によって、<code>array</code> のようなローカル変数は、内部クラスの <code>private</code> フィールド <code>val$array</code> にコピーされます。(<code>array</code> は <code>final</code> であるため、このようなコピーは決して一貫性のない値を含みません。) 各コピー値は、内部クラス構築子に同じ名前の別個の引数として渡されます。<p><a name="14955"></a>
次に結果の変換済コードを示します: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="10588"></a>    Enumeration myEnumerate(final Object array[]) {
    <a name="10590"></a>        return new MyOuterClass$19(array);
    <a name="10591"></a>    }
    <a name="10594"></a>...
    <a name="10643"></a>class MyOuterClass$19 implements Enumeration {
    <a name="10633"></a>    private Object val$array[];
    <a name="19860"></a>    int count;
    <a name="10638"></a>    MyOuterClass$19(Object val$array[])
    <a name="10639"></a>        { this.val$array = val$array; count = 0; }
    <a name="10626"></a>    public boolean hasMoreElements()
    <a name="10600"></a>        { return count &lt; val$array.length; }
    <a name="10602"></a>    public Object nextElement()
    <a name="10603"></a>        { return val$array[count++]; }
    <a name="10605"></a>}
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p><a name="15081"></a>
コンパイラは、変数を内部クラス構築子内だけで使用すると決定できる場合、内部クラスフィールドを変数に割り当てることを避ける可能性があります。<p><a name="15128"></a>
<code>E</code> のようなブロックが定義するクラスは親クラスのメンバではなく、そのブロック外で名前を付けることができないことに注意してください。これはローカル変数に適用されるものと同じスコーピングの制限で、これもまたブロック外で名前を付けられません。事実、ブロック（直接または介在するローカルクラス内部）に含まれるすべてのクラスは、ブロック外で名前を付けられません。このようなクラスすべては<em>アクセス不可能</em>と呼ばれます。リンクするためには、コンパイラはすべてのアクセス不可能クラスに対して、一意な外部から可視な名前を生成する必要があります。これらの名前の総括的な形式は、クラス名の後に追加の数字または名前を付け、<code>$</code> 文字で分離します。<p><a name="19882"></a>
また、<code>this$</code> および <code>val$</code> で始まるコンパイラが合成した変数名は、ここで説明する使用パターンに従う必要があります。<p><a name="20251"></a>これらの名前と規則は 1.1 準拠のツールに認識される必要があり、したがってほとんどコンパイル目的のために、従うことを強く求められます。このことについてはバイナリ互換の節でさらに検討します。<p><a name="20582"></a>
奇妙な名前の付いた"<code>this$</code>"と"<code>val$</code>"フィールドおよび余分な構築子引数は、コンパイラによって生成されたバイトコードに追加され、Java ソースコードで直接参照することはできません。同様に、<code>MyOuterClass$19</code> のようなバイトコードレベルのクラス名をソースコードが使用することはできません（内部クラスについてなにも知らない 1.1 以前のコンパイラを除く）。<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc1.html">前項目</a> | <a href="innerclasses.doc3.html">次項目</a> 

<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
