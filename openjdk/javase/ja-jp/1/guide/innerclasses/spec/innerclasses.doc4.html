<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc3.html">前項目</a> | <a href="innerclasses.doc5.html">次項目</a> 
</td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="13534"></a>
<h1>Java コードにおいて内部クラスが <code><b>this</b></code> という考え方にどのように影響するか？</h1>
<a name="15577"></a>
トップレベルクラス <var>T</var> のコードは、キーワード <code>this</code> によって直接、または <var>T</var> のインスタンスメンバの 1 つを命名することによって間接的に、<em>カレントインスタンス</em>を利用できることを思い出してください。カレントインスタンスの考え方は拡張され、内部クラスは 1 つ以上のカレントインスタンスを持ちます。これによって、内部クラス <var>C</var> のコードは <var>C</var> のカレントインスタンスと同様に、その外部クラスの親インスタンスと関連して実行できるようになります。<p><a name="15589"></a>
アダプタクラスの最初の例で、<code>Enumerator</code> コードは 2 つのカレントインスタンス、親 <code>FixedStack</code> および  <code>Enumerator</code> オブジェクト自身を持ちます。もっと一般的には、内部クラス <var>C</var> の本体全体の内部に、 <var>C</var> のカレントインスタンス、さらに、<var>C</var> を囲むすべての内部クラスのカレントインスタンス、最後に最奥の囲むトップレベルクラスのカレントインスタンスがあります。(<code>static</code> クラスはトップレベルであり、内部クラスではありません。そのため、カレントインスタンスの列挙は最初の <code>static</code> キーワードで終りです。)<p><a name="19951"></a>
トップレベルクラスは複数のカレントインスタンスを持ちません。トップレベルクラス <var>T</var> の非 <code>static</code> コード内では、型 <var>T</var> の 1 つのカレントインスタンスがあります。トップレベルクラス <var>T</var> の <code>static</code> コード内では、カレントインスタンスはありません。これはパッケージメンバであるトップレベルクラスについては常に true であり、他のトップレベルクラスの <code>static</code> メンバであるトップレベルクラスについても true です。これはすべてのパッケージメンバが暗示的にずっと <code>static</code> であったかのようです。<p><a name="15608"></a>
すべてのクラスにおいて、各カレントインスタンスを明示的に命名するか、またはそのメンバが使用されるとき暗示的な役割を演じさせることができます。すべてのカレントインスタンスは、あたかもそれが名前であるかのように、明示的にキーワード <code>this</code> を修飾して参照することができます:  <code>FixedStack.this</code>、<code>Enumerator.this</code>などのように。(この言語によって、内部クラスが親クラスのどれとも同じ名前を持つことを禁じられるため、この表記法は常に有効です。) いつものように、最奥のカレントインスタンスは修飾されていないキーワード <code>this</code> で命名できます。<p><a name="13538"></a>
インスタンス変数参照 <var>m</var> はフィールド参照式 <code>this.</code><var>m</var> と同じ意味を持ち、そのためカレントインスタンスが暗示的に使用されることを覚えておいてください。所定のコード内では、全カレントクラスのメンバすべてがスコープ内にあり、使用可能です(干渉スコープが覆い隠す名前を除いて)。メンバの簡単な名前は、そのクラスで名前が発見されたカレントインスタンスによって暗示的に修飾されます。(親クラスのすべての <code>static</code> メンバは常に使用可能です。)<p><a name="15629"></a>
とりわけ、Java コードは、すべてのカレントインスタンスのすべてのメソッドを直接使用することができます。クラスのスコープは過負荷には影響しません: 内部クラスが 1 つの <code>print</code> メソッドを持っている場合、修飾名のないメソッド名 <code>print</code> はそのメソッドを参照しますが、親クラスの 10 個の <code>print</code> メソッドのどれも参照できません。<p><a name="15634"></a>
<h2>		 親クラスおよびインスタンス生成</h2>
<a name="15628"></a>
内部クラス <var>C</var> の<em>親インスタンス</em>について述べることは時に有用です。これは <var>C</var> 自身のインスタンスでなく、 <var>C</var> 内部のどれかのカレントインスタンスとして定義されます。<var>C</var> のすべてのインスタンスは、親インスタンスと永久的に関連します。<p><a name="13541"></a>
構築子が起動されるとき、新しいオブジェクトが親インスタンスと共に供給される必要があります。この親インスタンスは、新しいオブジェクトが実行するすべてのコードのカレントインスタンスになります。(親インスタンスのレイヤがある場合、最奥のものが要求され、これは代わりに他のすべてを決定します。) 親インスタンスは、キーワード <code>new</code> を修飾することによって、明示的に指定が可能です: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="15682"></a>class Automobile {
    <a name="15684"></a>    class Wheel {
    <a name="15686"></a>        String hubcapType;
    <a name="15687"></a>        float radius;
    <a name="15685"></a>    }
    <a name="15697"></a>
    <a name="15743"></a>    Wheel leftWheel = this. new Wheel();
    <a name="15728"></a>    Wheel rightWheel = this. new Wheel();
    <a name="15734"></a>    Wheel extra;
    <a name="15742"></a>
    <a name="15729"></a>    static void thirdWheel(Automobile car) {
    <a name="15735"></a>        if (car.extra == null) {
    <a name="15736"></a>            car.extra = car. new Wheel();
    <a name="15739"></a>        }
    <a name="15730"></a>        return car.extra;
    <a name="15731"></a>    }
    <a name="15698"></a>}
    <a name="15714"></a>
    <a name="15715"></a>class WireRimWheel extends Automobile.Wheel {
    <a name="15717"></a>    WireRimWheel(Automobile car, float wireGauge) {
    <a name="15725"></a>        car. super();
    <a name="15724"></a>    }
    <a name="15716"></a>}
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p><a name="15679"></a>
内部クラス <var>C</var> のサブクラスは親インスタンスを <var>C</var> の構築子に渡す必要があります。これは今示したように、キーワード <code>super</code> を明示的に修飾することによって行われます。デフォルトでは、呼び出し側のカレントインスタンスが、新しい内部オブジェクトの親インスタンスになります。以前の例では、式 <code>new Enumerator()</code> は明示的に修飾された <code>this.new Enumerator()</code> と同等です。このデフォルトはほとんど常に正しいですが、あるアプリケーション（ソースコードジェネレータなど）では、それを時にオーバーライドする必要があるかもしれません。<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc3.html">前項目</a> | <a href="innerclasses.doc5.html">次項目</a> 

<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
