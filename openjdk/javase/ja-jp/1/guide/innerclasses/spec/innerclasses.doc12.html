<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc11.html">前項目</a> | <a href="innerclasses.doc13.html">次項目</a> 
</td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="13527"></a>
<h1>補足例:  調整済内部クラスを持つ API</h1>
<a name="13236"></a>
クラスベースの API は、基本的な機能として第 2 のクラスまたはインタフェースを有する場合があります。これら後者のものは、メインクラスの <code>static</code> 内部クラスとしてごく自然に構造化できます。<p><a name="13254"></a>
この例を見るには、インタフェース <code>Comparer</code> を持った仮説のユーティリティ <code>Sort</code> を想像してください。このインタフェースは比較操作とたくさんの標準の再利用可能な比較実装を仮想化します。(この例には欠点があります:  <code>Comparer</code> は自立するにはあまりに一般的です。) コードは次のようにします: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="13257"></a>public class Sorter {
    <a name="13262"></a>    public interface Comparer {
    <a name="13263"></a>        /** Returns &lt;0 if x &lt; y, etc. */
    <a name="13264"></a>        int compare(Object x, Object y);
    <a name="13265"></a>    }
    <a name="13325"></a>    public static void sort(Object keys[], Comparer c) {...}
    <a name="13333"></a>    public static void sort(Object keys[], Comparer c,
    <a name="13334"></a>                            Object values[]) {...}
    <a name="13336"></a>    public static void sort(String keys[], Object values[])
    <a name="13349"></a>        { sort(keys, stringComparer, values); }
    <a name="13346"></a>
    <a name="13268"></a>    public static class StringComparer implements Comparer {
    <a name="13269"></a>        public int compare(Object x, Object y) {
    <a name="13270"></a>            if (x == null)  return (y == null) ? 0 : -1;    <a name="13271"></a>            if (y == null)  return 1;
    <a name="13272"></a>            return x.toString().compareTo(y.toString());    <a name="13273"></a>        }
    <a name="13274"></a>    }
    <a name="13275"></a>    public static final Comparer stringComparer
    <a name="13294"></a>            = new StringComparer();
    <a name="13276"></a>
    <a name="13277"></a>    public static class LongComparer implements Comparer {
    <a name="13285"></a>            ... long lx = ((Number)x).longValue(); ...
    <a name="15765"></a>    }
    <a name="13286"></a>    public static final Comparer longComparer
    <a name="13301"></a>            = new LongComparer();
    <a name="13287"></a>
    <a name="13314"></a>    /** Compose 2 comparisons, presumably on distinct sub-keys. */
    <a name="13288"></a>    public static class CombinedComparer implements Comparer {...}
    <a name="13289"></a>    public static Comparer combine(Comparer c1, Comparer c2) {...}
    <a name="13313"></a>    ...
    <a name="13290"></a>}
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc11.html">前項目</a> | <a href="innerclasses.doc13.html">次項目</a> 

<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
