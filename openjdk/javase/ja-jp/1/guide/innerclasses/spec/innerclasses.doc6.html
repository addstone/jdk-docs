<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc5.html">前項目</a> | <a href="innerclasses.doc7.html">次項目</a> 
</td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="16657"></a>
<h1> ネストされたクラスを <code><b>final</b></code>、<code><b>private</b></code>、 <code><b>protected</b></code>、または <code><b>static</b></code> と宣言することができるか?</h1>
<a name="11040"></a>
既存アクセスの保護と修正モードはすべて、他のクラスのメンバである型に通常どおりに適用されます。クラスとインタフェースはその親クラス内で <code>private</code> または <code>protected</code> と宣言することができます。<p><a name="11042"></a>ブロックに対してローカルであるクラスはメンバではなく、そのため <code>public</code>、<code>private</code>、<code>protected</code> または <code>static</code> にはなれません。これはスコープ外で使用できないため、事実上ブロックに対して private です。<p><a name="16859"></a>
アクセス保護は、1 つのクラスが他を囲むか、または第 3 のクラスにそれらが囲まれる限り、クラスが他のクラスのメンバを使用することを防ぐことはできません。<p><a name="13907"></a>
すべてのクラス（それが名前を持つ場合）を <code>final</code> または <code>abstract</code> と宣言でき、すべてのアクセス可能な非 <code>final</code> の名前を持つクラスまたはインタフェースは、スーパータイプとして機能できます。コンパイラはまた、クラスがサブクラスを持たず、サブクラスを後で追加する方法もないと判別できる場合、クラスを <code>final</code> に変更する可能性があります。これは、<code>private</code> またはブロックローカルクラスがスコープ内にサブクラスを持たないときに可能です。<p><a name="13908"></a>
<h2>		 <code><b>static</b></code> とマークできるメンバ</h2>
<a name="13909"></a>
<code>static</code> 宣言修飾子はプログラマに、特定のインスタンスよりは全体としてクラスに適した、<em>クラスメソッド</em>および<em>クラス変数</em>を定義する方法を与えるために設計されました。 これらは「トップレベル」エンティティです。<p><a name="19978"></a>
<code>static</code> キーワードもまた、トップレベルクラス <var>T</var> の本体内のクラス <var>C</var> の宣言を修正する可能性があります。この効果は <var>C</var> もまたトップレベルクラスであると宣言することです。<var>T</var> のクラスメソッドが本体に <var>T</var> のカレントインスタンスを持たないように、<var>C</var> もまた <var>T</var> のカレントインスタンスを持ちません。こうして、<code>static</code> のこの新しい使用法は任意ではありません。<p><a name="16806"></a>
トップレベルクラス（ネストしているかどうかに関わらず）とは反対に、内部クラスは <code>static</code> メンバをなに 1 つ宣言できません。内部クラスに対してクラス変数を作成するためには、プログラマは希望する変数を親クラスに配置する必要があります。<p><a name="16807"></a>
<code>static</code> キーワードは常に、親インスタンスに決して従属しない「トップ
レベル」構築物（変数、メソッド、またはクラス）をマークするというように使用すると、この時点では役に立ちます。<p><a name="16848"></a>
これはなぜ内部クラスが <code>static</code> メンバを宣言できないかを示します。それは、内部クラスの本体全体が、 1 つ以上の親インスタンスのスコープにあるからです。<p><a name="16851"></a>
C 言語はブロックローカル <code>static</code> 変数を許容しますが、同じ効果は Java においても、希望する長寿の変数を必要な寿命に対応したスコープ内に定義して、もっと普通にそして保守性のいい形でその効果を得ることができます。<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc5.html">前項目</a> | <a href="innerclasses.doc7.html">次項目</a> 

<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
