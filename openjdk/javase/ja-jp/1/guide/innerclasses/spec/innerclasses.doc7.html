<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc6.html">前項目</a> | <a href="innerclasses.doc8.html">次項目</a> 
</td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="11050"></a>
<h1>内部クラスは Java Virtual Machine の編成にどのように影響するか?</h1>
<a name="11051"></a>
Java Virtual Machine が処理するクラスファイルフォーマット、または標準クラスライブラリに変更はありません。新しい機能はコンパイラが実装します。バイトコードの構成は、すべての 1.1 準拠コンパイラがバイナリ互換のクラスファイルを生成するのに充分な精度で指定されます。<p><a name="11052"></a>
Java ソースコードの単一ファイルは、多くのクラスファイルについてコンパイルできます。これは新しい現象ではありませんが、強力な内部クラス表記法によって、プログラマは最後には比較的少ないコードで多数のクラスファイルを作成できるようになります。さらに、アダプタクラスはわずかなメソッドで非常に単純になります。これは、多くの内部クラスを使用する Java プログラムが、多くの小さなクラスファイルに対してコンパイルすることを意味します。このようなクラスに対するパッケージ化の技術は、これらクラスを合理的効率的にプロセスします。例えば、サンプルクラス <code>FixedStack.Enumeration</code> のクラスファイルは3/4 キロバイトを占めますが、その 40% はコードを実装するために直接必要です。この比率はファイルフォーマットの調整に応じて、改善されていくでしょう。virtual machine のメモリ使用パターンは互換です。<p><a name="11054"></a>
<h2>		 クラス名の変換</h2>
<a name="11055"></a>
ネストしたクラスの名前は必要に応じて、他のスコープ内の固有の名前と衝突しないようにコンパイラによって変換されます。名前は、ドットで修飾されたソースの形式を取り、クラス名の後の各ドット `<code>.</code>' をドル記号 `<code>$</code>' に変えることによって virtual machine にエンコードされます。(メカニカルトランスレータは Java でドル記号を使用することが許されます。)<p><a name="16948"></a>
クラス名が <code>private</code> またはブロックに対してローカルのとき、これはグローバルにアクセス不可能です。コンパイラは、アクセス可能な親クラス名を前置にして、後ろに `<code>$</code>' セパレータとローカルに一意な 10 進数を付けて、このようなアクセス不可能な名前をコード化する選択をする可能性があります。匿名クラスはこのようにエンコードする必要があります。<p><a name="16985"></a>
そこで、内部クラス <code>pkg.Foo.Bar</code> は、Bar が <code>private</code> メンバまたはローカルクラスの場合、<code>pkg.Foo$Bar</code> という実行名または <code>pkg.Foo$23</code> のような名前を取ります。実装は、グローバルにアクセス不可能なものでも、デバッガおよび同様のツールが認識できるように、名前のフォーマットを守る必要があります。<p><a name="16986"></a>
変換された名前を定義または使用するクラスファイルはすべて、（1.0 ファイルフォーマットでサポートされるように）変換を記録する属性もまた含みます。これらの属性は virtual machine および 1.0 コンパイラが無視できます。この属性のフォーマットはバイナリ互換の節で説明します。<p><a name="17017"></a>
<h2>		 生成された変数およびメソッドの名前</h2>
<a name="11496"></a>
前述したように、内部クラスが親スコープの変数を使用する場合、名前の式は親インスタンスのフィールドへの参照か、または <code>final</code> ローカル変数の値を提供する、カレントインスタンスのフィールドへの参照に変換されます。代わりに、親インスタンスへの参照は、もっとアクセス可能なカレントインスタンスのフィールドへの参照に変換されます。これらの技術には、コンパイラが内部クラス内の覆い隠されたフィールドを合成することが必要となります。<p><a name="17214"></a>
コンパイラが生成するメンバのもう 1 つのカテゴリがあります。クラス <var>C</var> 
の <code>private</code> メンバ <var>m</var> は、1 つのクラスが他を囲む場合、またはこれらが共通のクラスに囲まれる場合、別のクラスが使用する可能性があります。virtual machine はこの種のグループ化について知らないために、コンパイラは <var>D</var> がメンバ <var>m</var> を読み込み、書き込み、または呼び出しできるように、<var>C</var> のアクセスメソッドのローカルプロトコルを作成します。  これらのメソッドは形式 <code>access$0</code>、<code>access$1</code> などの名前を持ちます。これらは決して public にはなりません。アクセスメソッドは、内部クラスではなく<em>親</em>クラスに追加される可能性があるという点で一意です。<p><a name="17336"></a>
すべての生成された変数とメソッドはクラスファイル属性で宣言され、1.1 コンパイラはプログラムが直接これらを参照しないようにできます。<p><a name="17241"></a>
<h2>		 セキュリティの暗示</h2>
<a name="17289"></a>
内部クラス <var>C</var> が親クラス <var>T</var> の <code>private</code> メンバ <var>m</var> へのアクセスを要求する場合、<var>m</var> への挿入アクセスメソッドは <var>T</var> を同じパッケージのすべてのクラス <var>K</var> による不当なアクセスに対して開きます。現時点では、このようなアクセスメソッドに関してセキュリティの問題は報告されていません。それは、メソッドをパッケージスコープと共に誤使用することが難しいからです。コンパイラには、アクセスメソッドを作成するとき、可能なループホールの作成を監視するために警告を出すように指示することができます。<p><a name="17359"></a>
クラス <var>N</var> が別のクラス <var>C</var> の <code>protected</code> メンバである場合、<var>N</var> のクラスファイルはこれを <code>public</code> クラスとして定義します。クラスファイル属性は保護モードビットを正しく記録します。この属性は現在の virtual machine によって無視され、<var>C</var> のサブクラスに対してではなく、すべてのクラスの <var>N</var> に対するアクセスが許されます。もちろん、コンパイラは属性を調べるため、このようなエラーを正しく診断します。これは、悪意のあるユーザが簡単に <var>C</var> というサブクラスを作成し、<code>protected</code> かどうかに関わらず <var>N</var> へのアクセスを得ることができるため、セキュリティホールではありません。<p><a name="17362"></a>
同様に、クラスが別のクラスの <code>private</code> メンバである場合、そのクラスファイルはこれをパッケージスコープを持っていると定義し、属性は本当のアクセス保護を宣言するため、1.1 コンパイラはパッケージ内であっても不注意なアクセスを防ぐことができます。<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">コンテンツ</a> | <a href="innerclasses.doc6.html">前項目</a> | <a href="innerclasses.doc8.html">次項目</a> 

<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
