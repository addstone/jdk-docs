<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc12.html">前項目</a> | 次項目 </td><td align=right><i>内部クラス仕様</i></td>
</tr></table>

<hr><br>
 
<a name="15329"></a>
<h1>補足例:  マルチスレッドタスクのパーティション</h1>
<a name="15341"></a>
各サブタスクをスレッドに割り当てることによって、1 つのタスクを独立した複数のサブタスクに併行化することは、時々有用です。これによって、複数のプロセッサが関わる場合は、タスク全体が速く終了します。(複数のサブタスクがネットワークトラフィックを実行する場合が、このケースに該当します。) 対話型の Java プログラムでは、マルチスレッドが使用され、サブタスクからの部分的な結果をエンドユーザにプッシュできるようにしています。一方では遅いサブタスクが少しずつ処理を行います。<p><a name="16892"></a>
次のコード（Doug Lea の例に基づく）は、いくつかのピクチャのレンダリングを制御する非常に簡単な方法を示します。その方法は、各ピクチャは用意でき次第ディスプレーヤに送られますが、元の要求側はすべてのレンダリングが完了するまでブロックします。各サブタスクは各スレッドの心臓部である <code>Runnable</code> の匿名実装によってコード化されます。 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="16895"></a>public class GroupPictureRenderer {
    <a name="16896"></a>  private PictureRenderer renderer;
    <a name="16897"></a>  private PictureDisplayer displayer;
    <a name="16898"></a>  ...
    <a name="16899"></a>
    <a name="16900"></a>  public Picture[] render(final byte[][] rawPictures)
    <a name="16901"></a>                    throws InterruptedException {
    <a name="16902"></a>    Thread workers[] = new Thread[rawPictures.length];
    <a name="16903"></a>    final Picture results[] = new Picture[rawPictures.length];
    <a name="16904"></a>    // start one thread per rendering sub-task
    <a name="16905"></a>    for (int ii = 0; ii &lt; rawPictures.length; ii++) {    <a name="16906"></a>      final int i = ii;   // capture ii for each new thread
    <a name="16907"></a>      Runnable work = new Runnable() {
    <a name="16908"></a>            public void run() {
    <a name="16909"></a>              results[i] = renderer.render(rawPictures[i]);
    <a name="16910"></a>              displayer.display(results[i]);
    <a name="16911"></a>            }
    <a name="16912"></a>      };
    <a name="16913"></a>      workers[i] = new Thread(work, "Renderer");
    <a name="16914"></a>      workers[i].start();
    <a name="16915"></a>    }
    <a name="16916"></a>    // all threads are running; now wait for them all to finish
    <a name="16917"></a>    for (int i = 0; i &lt; workers.length; i++)
    <a name="16918"></a>      workers[i].join();
    <a name="16919"></a>    // give all the finished pictures to the caller, too:
    <a name="16920"></a>    return results;
    <a name="16921"></a>  }
    <a name="16922"></a>}
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
--><p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">目次</a> | <a href="innerclasses.doc12.html">前項目</a> | 次項目 
<p>
<font size=-1>内部クラス仕様 (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright (c) 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
コメントや訂正は <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a> 宛てに送ってください。
</font>
</body></html>
