<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title></title>
</head>
<body bgcolor=#ffffff>

<table width=600><tr>
<td><font size=-1>
<a href="introTOC.doc.html">目次</a>  | <a href="resultset.doc.html">前項目</a>  | <a href="callablestatement.doc.html">次項目</a>
</font></td><td align=right><i>JDBC<sup><font size=-2>TM</font></sup> ガイド: 「はじめましょう」</i></td>
</tr></table>
<hr>
<br>
 
<a name="999738"></a>
<h1>6  - PreparedStatement</h1>
<a name="999751"></a>
この概要は、現在 JavaSoft で作成中の <em>JDBC<font size=-1><sup>TM</sup></font> Database Access from Java<font size=-1><sup>TM</sup></font>:  A Tutorial and Annotated Reference</em> からの引用です。この本は JDBC の自習書であるとともに決定版リファレンスマニュアルで、1997 年春に Addison-Wesley Publishing Company から Java シリーズの一部として発行されています。 
<p><a name="999746"></a>

<p>

<a name="996870"></a>
<h2>6.1	 &nbsp;&nbsp; 概要</h2>
<a name="999753"></a>
<code>PreparedStatement</code> インタフェースは、<code>Statement</code> から継承しますが、以下の 2 つの点で異なります。
<p><ol>
<a name="999754"></a>
<li><code>PreparedStatement</code> のインスタンスには、すでにコンパイル済みの SQL 文が入っています。文が "prepared" (準備済み) と呼ばれるのはこのためです。


<a name="999755"></a>
<li><code>PreparedStatement</code> に入っている SQL 文には、1 つ以上の IN パラメータを付けることができます。IN パラメータは、SQL 文が作成されたときにはその値が指定されていないパラメータです。その代わり、文には IN パラメータのプレースホルダとして疑問符 ("?") が付いています。それぞれの疑問符の値は、文を実行する前に適切な <code>setXXX</code> メソッドによって供給される必要があります。   

</ol>
<a name="999756"></a>
<code>PreparedStatement</code> オブジェクトはすでにコンパイル済みなので、<code>Statement</code> オブジェクトより高速に実行することができます。したがって、何度も実行される SQL 文は、 <code>PreparedStatement</code> オブジェクトとして作成して効率を高めることがよくあります。
<p><a name="999757"></a>
<code>PreparedStatement</code> は <code>Statement</code> のサブクラスであるため、<code>Statement</code> のすべての機能を継承します。さらに、IN パラメータのプレースホルダの代わりにデータベースに送信する値を設定するのに必要な全てのメソッドを追加します。また、3 つのメソッドの <code>execute</code>、<code>executeQuery</code>、および <code>executeUpdate</code> は、引数を取らないように変更されています。この 3 つのメソッドの <code>Statement</code> 形式 (SQL 文のパラメータを取る形式) は、
<code>PreparedStatement</code> オブジェクトに対しては絶対に使用してはなりません。
<p>

<a name="999758"></a>
<h3>6.1.1	 &nbsp;&nbsp; PreparedStatementオブジェクトの作成</h3>
<a name="999759"></a>
以下のコードの一部分 (<code>con</code> は <code>Connection</code> オブジェクト)は、IN パラメータのための 2 つのプレースホルダがある SQL 文の <code>PreparedStatement</code> オブジェクトを作成します。
<p><pre><a name="999760"></a>    PreparedStatement pstmt = con.prepareStatement(
<a name="999761"></a>        "UPDATE table4 SET m = ? WHERE x = ?");
</pre><a name="999762"></a>
これで、オブジェクト <code>pstmt</code> には、<code>"UPDATE table4 SET m = ? WHERE x = ?"</code> という文が入り、DBMS に送信されて実行準備済みの状態になります。
<p>

<a name="999763"></a>
<h3>6.1.2	 &nbsp;&nbsp; IN Parametersの引き渡し</h3>
<a name="999764"></a> 
<code>PreparedStatement</code> オブジェクトが実行される前に、各 <code>?</code> パラメータの値を設定する必要があります。これは、<code>setXXX</code> メソッドを呼び出すことによって行います (<code>XXX</code> は、パラメータの適切な型です。たとえば、パラメータが <code>long</code> という Java の型を持つ場合、使用するメソッドは <code>setLong</code> です。<code>setXXX</code> メソッドの最初の引数は、設定するパラメータの<em>順序</em>で、2 番目の引数は、パラメータに設定する<em>値</em>です。たとえば、以下のコードは、最初のパラメータを <code>123456789</code> に、2 番目のパラメータを <code>100000000</code> に設定します。
<p><pre><a name="999765"></a>    pstmt.setLong(1, 123456789);
<a name="999766"></a>    pstmt.setLong(2, 100000000);
</pre><a name="999767"></a>
その文にパラメータの値が設定されると、そのパラメータは、メソッド <code>clearParameters</code> への呼び出しによってクリアされるまで、その文が実行されるたびに何度でも使用されます。
<p>
<a name="999768"></a>
接続のためのデフォルトモード（自動コミット有効）では、接続が確立されると各文が自動的にコミットされたり、ロールバックされたりします。
<p>
<a name="999769"></a>
<code>PreparedStatement</code> オブジェクトは、コミット後、基盤のデータベースとドライバがそれを開いたままにしていれば、同じオブジェクトを複数回実行することができます。ただし、これ以外の場合は、<code>Statement</code> オブジェクトの代わりに <code>PreparedStatement</code> オブジェクトを使用してパフォーマンスの向上を試みることには、まったく意味がありません。
<p>
<a name="999770"></a>
以下のコードでは、上で作成した <code>pstmt</code>、<code>PreparedStatement</code> オブジェクトを使用して、2 つのパラメータのプレースホルダの値の設定と <code>pstmt</code> を 10 回実行する方法を説明します。前述のように、これが機能するためには、データベースが <code>pstmt</code>を閉じないようにする必要があります。この例では、最初のパラメータに <code>"Hi"</code> が設定され、定数のままになります。2 番目のパラメータには、<code>0</code> で始まり、<code>for</code> ループを通るたびに異なる値が設定されて、最後は <code>9</code> で終ります。

<p>
<pre><a name="999771"></a>    pstmt.setString(1, "Hi");  
<a name="999772"></a>    for (int i = 0; i &lt; 10; i++) {
<a name="999773"></a>      pstmt.setInt(2, i);
<a name="999774"></a>      int rowCount = pstmt.executeUpdate();
<a name="999775"></a>    }
</pre>
<a name="999776"></a>
<h3>6.1.3	 &nbsp;&nbsp; IN Parametersにおけるデータ型の適合性</h3>
<a name="999777"></a>
<code>setXXX</code> メソッドの <code>XXX</code> は Java の型です。ドライバが (この<em>JDBC ガイド</em>の <a href="mapping.doc.html#1004752">8.6.2</a> 節、「JDBC の型にマップされる Java の型」 の一覧に指定されたマッピングに従って、) Java の型を対応する SQL の型にマッピングし、その SQL タイプをデータベースに送信するので、これは暗黙的には SQL の型です。たとえば、以下の部分的なコードは、<code>PreparedStatement</code> オブジェクト <code>pstmt</code> の 2 番目のパラメータを <code>short</code> という Java の型で <code>44</code> に設定します。
<p><pre><a name="999781"></a>    pstmt.setShort(2, 44);
</pre><a name="999782"></a>
ドライバは 44 を、 Java の <code>short</code> からの標準マッピングである JDBC の <code>SMALLINT</code> としてデータベースに送信します。
<p><a name="999783"></a> 
Java 型の各 IN パラメータが、データベースが期待する JDBC のデータ型と互換性のある JDBC の型に確実にマップするかは、プログラマの責任です。データベースが JDBC 
<code>SMALLINT</code> を期待している場合を想定してください。メソッド <code>setByte</code> が使用される場合、ドライバは、 JDBC の <code>TINYINT</code> をデータベースに送信します。多くのデータベースでは、1 つの関連する型から他の型に変換すること、また一般に <code>TINYINT</code> は、<code>SMALLINT</code> が使用されているところではどこでも使用できることから、これはおそらく機能するでしょう。しかし、アプリケーションができるだけ多くのデータベースで機能するためには、データベースが期待する正確な JDBC の型に対応する Java の型を使用するのが最もよい方法です。期待される JDBC の型が <code>SMALLINT</code> の場合、<code>setByte</code> の代わりに <code>setShort</code> を使用することにより、アプリケーションの移植性を向上させることができます。
<p>

<a name="999785"></a>
<h3>6.1.4	 &nbsp;&nbsp; setObject の使用</h3>
<a name="999786"></a>
プログラマは、メソッド <code>setObject</code> を使用して、入力パラメータを特定の JDBC の型に明示的に変換することができます。このメソッドは、3 番目の引数を取って、対象の JDBC の型を指定することができます。ドライバは、Java の <code>Object</code> を指定した JDBC の型に変換してからデータベースに送信します。 
<p>
<a name="999787"></a>
JDBC の型が指定されていない場合、ドライバは（<a href="mapping.doc.html#1004830">8.6.4</a> 節の一覧を使用して、）単純に Java の <code>Object</code> をそのデフォルトの SQL の型にマップして、データベースに送信します。これは、通常の <code>setXXX</code> の処理と似ています。いずれの場合も、ドライバが Java の型を適切な JDBC の型に変換してから、データベースに送信します。相違点としては、<code>setXXX</code> メソッドが、Java の型から JDBC の型への標準のマッピングを使用するのに対し (
<a href="mapping.doc.html#1004752">9.5.2</a> 節の一覧参照)、<code>setObject</code> メソッドは、Java の <code>Object</code> 型から JDBC の型へのマッピングを使用します (<a href="mapping.doc.html#1004830">8.6.4</a> 節の一覧参照)。 
<p>
<a name="999798"></a>
メソッド <code>setObject</code> はあらゆる Java オブジェクトを許容する能力を持つため、アプリケーションを汎用化して、パラメータ入力を実行時に受け取ることができます。その場合、アプリケーションのコンパイル時には入力の型は不明です。<code>setObject</code> を使用することにより、アプリケーションは任意の Java のオブジェクト型を入力として受け取り、それをデータベースが期待する JDBC の型に変換することができます。<a href="mapping.doc.html#1004845">8.6.5</a> 節の一覧に、<code>setObject</code> が実行できるすべての変換を示します。 
<p>

<a name="999802"></a>
<h3>6.1.5	 &nbsp;&nbsp; JDBC NULL の IN パラメータとしての送信</h3>
<a name="999803"></a>
<code>setNull</code> メソッドにより、プログラマは、 JDBC の <code>NULL</code> 値を IN パラメータとしてデータベースに送信することができます。ただし、 JDBC 型のパラメータを指定することが必要になることに注意してください。

<p><a name="999804"></a>
Java の <code>null</code> 値が <code>setXXX</code> メソッドに渡された場合、 JDBC の <code>NULL</code> もデータベースに送信することができます (Java オブジェクトを引数として取る場合)。ただし、メソッド
<code>setObject</code> が <code>null</code> 値を取れるのは、 JDBC の型が指定されている場合に限ります。
<p>

<a name="999805"></a>
<h3>6.1.6	 &nbsp;&nbsp; きわめて大きな IN パラメータの送信</h3>
<a name="999806"></a>
メソッド <code>setBytes</code> および <code>setString</code> は、無限の量のデータを送信することができます。ただし、ときによっては、プログラマが大量のデータを小さな塊で渡したいと考えることがあります。これは、IN パラメータを Java 入力ストリームに設定することによって達成できます。文の実行時に、JDBC ドライバがこの入力ストリームを繰り返し呼び出し、その内容を読みとって、それを実際のパラメータデータとして伝送します。
<p><a name="999807"></a>
JDBC には、IN パラメータを入力ストリームに設定するための方法が 3 通りあります。これらは、未解釈のバイトが入ったストリームのための 
<code>setBinaryStream</code>、ASCII 文字の入ったストリームのための <code>setAsciiStream</code>、および Unicode 文字の入ったストリームのための <code>setUnicodeStream</code> です。これらのメソッドは、ストリーム全体の長さを指定する必要があるので、他の <code>setXXX</code> メソッドより引数を 1 つ多く取ります。データベースによっては、データ送信の前に全転送サイズを知る必要があるので、この引数が必要になります。

<p>
<a name="999808"></a>
以下のコードは、ストリームを使用し、ファイルの内容を IN パラメータとして送信する方法を示します。 
<p>
<pre><a name="999809"></a>    java.io.File file = new java.io.File("/tmp/data");
<a name="999810"></a>    int fileLength = file.length();
<a name="999811"></a>    java.io.InputStream fin = new java.io.FileInputStream(file);
<a name="999812"></a>    java.sql.PreparedStatement pstmt = con.prepareStatement(
<a name="999813"></a>      "UPDATE Table5 SET stuff = ? WHERE index = 4");
<a name="999814"></a>    pstmt.setBinaryStream (1, fin, fileLength);
<a name="999815"></a>    pstmt.executeUpdate();
</pre><a name="999816"></a>
文が実行されると、入力ストリーム <code>fin</code> が繰り返し呼び出され、そのデータを配信します。 
<p>
<pre><a name="998420"></a>    
</pre>

<br>
<hr>
<font size=-1>
<a href="introTOC.doc.html">目次</a>  | <a href="resultset.doc.html">前項目</a>  | <a href="callablestatement.doc.html">次項目</a>
</font>
<hr>


<address>
<a href="mailto:jdbc@wombat.eng.sun.com">jdbc@wombat.eng.sun.com</a>
または
<a href="mailto:jdbc-odbc@wombat.eng.sun.com">jdbc-odbc@wombat.eng.sun.com</a>
</address>

<a href="copyright.doc.html">
<font size=-1><i>Copyright (C) 1996, 1997 Sun Microsystems, Inc.   All rights reserved.</i></font>
</a>

<!-- HTML generated by dkramer on March 14, 1997 -->

</body>
</html>

