<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title> </title>
</head>
<body bgcolor=#ffffff>

<table width=600><tr>
<td><a href="jniTOC.doc.html">目次</a> | <a href="copyright.doc.html">前項目</a> | <a href="design.doc.html">次項目</a> 
</td><td align=right><i> Java ネイティブインタフェース仕様
</i></td>
</tr></table>
 

<hr><br>
 
<h1><a name="16170"></a>
<strong> 1 -  はじめに
 </strong></h1>
<hr><p><a name="16173"></a>
この章では、<em>Java ネイティブインタフェース</em> (JNI) を紹介します。JNI は、ネイティブプログラミングインタフェースです。これによって、Java Virtual Machine (VM)で実行される Java コードが C、C++、アセンブリ言語など他のプログラミング言語で書かれたアプリケーションやライブラリと相互運用できるようになります。
<p><a name="426"></a>
JNI の最も重要な利点は、これが基礎となる Java VM の実装に何の制限も課さないということです。そのため、Java VM ベンダは VM の他の部分に影響を与えずに、JNI のサポートを追加できます。プログラマは、ネイティブアプリケーションまたはライブラリの 1 つのバージョンを書き、これが JNI をサポートするすべての Java VM と動作することを期待できます。
<p><a name="514"></a>
この章では次の説明項目を扱います
<p><ul><a name="560"></a>
<li><a href="intro.doc.html#16635"><em>Java ネイティブインタフェース概要</em></a>

<a name="586"></a>
<li><a href="intro.doc.html#16230"><em>背景</em></a>

<a name="565"></a>
<li><a href="intro.doc.html#16410"><em>目的</em></a>

<a name="569"></a>
<li><a href="intro.doc.html#16465"><em>Java ネイティブインタフェースのアプローチ</em></a>

<a name="573"></a>
<li><a href="intro.doc.html#16539"><em>JNI でのプログラミング</em></a>

</ul><hr align=left><a name="16635"></a>
<h1> Java ネイティブインタフェースの概要
</h1>
<a name="16636"></a>
Java でアプリケーション全体を書くことができる一方、Java だけでアプリケーションのニーズを満たせない状況もあります。Java でアプリケーション全体を書くことができないとき、こうした状況を処理するためにプログラマは JNI を使用し、<em>Java ネイティブメソッド</em>を書きます。 
<p><a name="16650"></a>
次の例は Java ネイティブメソッドを使用する必要のある場合です。
<p><ul><a name="16651"></a>
<li>標準 Java クラスライブラリが、アプリケーションが必要とするプラットフォーム依存機能をサポートしない。 

<a name="16654"></a>
<li>既に他の言語で書かれたライブラリを持っており、それに JNI を経由して Java コードからアクセスしたいと希望している。 

<a name="16656"></a>
<li>一部のタイムクリティカルなコードをアセンブリなどの低レベル言語で実装することを望む。

</ul><a name="16395"></a>
JNI のプログラミングによって、次のことを行うネイティブメソッドを使用することができます。
<p><ul><a name="16398"></a>
<li>Java オブジェクトを生成、検査、更新する(配列と文字列を含む)。

<a name="16396"></a>
<li>Java メソッドを呼び出す。

<a name="16404"></a>
<li>例外をキャッチしスローする。

<a name="16407"></a>
<li>クラスをロードし、クラス情報を得る。

<a name="16659"></a>
<li>実行時の型チェックを実行する。

</ul><a name="16360"></a>
また、任意のネイティブアプリケーションが Java VM を埋め込むことができるようにするには、 <em>呼び出し API</em>と共に JNI を使用します。これによって、プログラマは VM ソースコードにリンクせずに簡単に、既存のアプリケーションを Java 使用可能にできます。
<p><hr align=left><a name="16230"></a>
<h1> 背景
</h1>
<a name="16412"></a>
現在、異なるベンダの VM は異なるネイティブメソッドインタフェースを提供します。これらの異なるインタフェースによって、プログラマは与えられたプラットフォームで複数バージョンのネイティブメソッドライブラリを生成、維持、配布することが必要になります。
<p><a name="16679"></a>
既存の代表的なネイティブメソッドインタフェースを以下に紹介します。
<p><ul><a name="16685"></a>
<li>JDK 1.0 ネイティブメソッドインタフェース

<a name="16688"></a>
<li>Netscape の Java ランタイムインタフェース

<a name="16689"></a>
<li>Microsoft の ローネイティブインタフェースおよび Java/COM インタフェース

</ul><br><a name="16684"></a>
<h2>		 JDK 1.0 ネイティブメソッドインタフェース
</h2>
<a name="16555"></a>
JDK 1.0 は、ネイティブメソッドインタフェースを添付して出荷されました。残念ながら、2つ
の大きな理由のため、このインタフェースは他の Java VM への適用には適しません。
<p><a name="16700"></a>
第 1 にネイティブコードは、Java オブジェクトのフィールドに C 構造体のメンバとしてアクセスします。しかし<em>Java 言語仕様</em>は、オブジェクトをメモリにどのように配置するかを定義していません。VM がオブジェクトをメモリに異なって配置する場合、プログラマはネイティブメソッドライブラリを再コンパイルする必要があります。 
<p><a name="16705"></a>
第 2 に、JDK 1.0 のネイティブメソッドインタフェースは厳格なガベージコレクタに
依存しています。例えば、制限のない <code>unhand</code> マクロの使用によってネイティブスタックを慎重に調べる必要がでてきます。
<p><br><a name="16413"></a>
<h2>		 Java ランタイムインタフェース
</h2>
<a name="16706"></a>
Netscape は Java virtual machine で提供されるサービスの一般的なインタフェースで
ある、Java ランタイムインタフェース(JRI)を提案しました。JRI は移植性を念頭に設計されています---これは基礎となる Java VM の実装の詳細についてわずかしか考慮していません。JRI はネイティブメソッド、デバッギング、リフレクション、埋め込み(呼び出し)などを含めて、広範囲をサポートしています。
<p><br><a name="16442"></a>
<h2>		 ローネイティブインタフェース および Java/COM インタフェース
</h2>
<a name="16707"></a>
Microsoft Java VM は、2 つのネイティブメソッドインタフェースをサポートします。低レベルでは、効率的なローネイティブインタフェース(RNI)を提供します。 JDK のネイティブメソッドインタフェースとのソースレベルの高度の後方互換性を提供しますが、 RNI には大きな違いが 1 つあります。厳格なガベージコレクションに依存する代わりに、ネイティブコードは RNI 機能を使用し明示的にガベージコレクタと相互動作しなければなりません。
<p><a name="16713"></a>
高レベルでは、Microsoft の Java/COM インタフェースは Java VM に対して言語独立の標準バイナリインタフェースを提供します。Java コードは COM オブジェクトをあたかも Java オブジェクトであるかのように使用できます。Java クラスもまた COM クラスとしてシステムの残りに開示することができます。
<p><hr align=left><a name="16410"></a>
<h1> 目的
</h1>
<a name="16664"></a>
充分検討された統一標準インタフェースは誰にも次のような利点を提供するはずです。

<p><ul><a name="16184"></a>
<li>各 VM ベンダはネイティブコードのより大きな本体をサポートできる。

<a name="16186"></a>
<li>ツールビルダは、異なる種類のネイティブメソッドインタフェースを維持する必要はない。

<a name="16268"></a>
<li>アプリケーションプログラマは、ネイティブコードの 1 つのバージョンを書くことができ、このバージョンは異なる VM 上で動作する。

</ul><a name="16250"></a>
標準のネイティブメソッドインタフェースを達成する最善の方法は、Java VM に関心の
あるすべての関係者を取り込むことです。このため、統一されたネイティブメソッドインタフェースの設計について Java ライセンシーの間で一連の検討を行いました。標準のネイティブメソッドインタフェースは、次の要件を満たす必要があることが検討から明らかになりました。
<p><ul><a name="16251"></a>
<li>バイナリ互換 - 主要な目標は、与えられたプラットフォーム上のすべての Java VM 実装全体でのネイティブメソッドライブラリのバイナリ互換です。 

<a name="16463"></a>
<li>効率 - タイムクリティカルコードをサポートするためには、ネイティブメソッドインタフェースはわずかのオーバーヘッドしか課してはなりません。VM 独立(およびバイナリ互換)を保証する既知の技術のすべては、ある量のオーバーヘッドをもたらします。効率と VM 独立の間にある程度の譲歩をする必要があります。

<a name="16464"></a>
<li>機能性 - インタフェースはネイティブメソッドが有用なタスクを達成できるようにするために、充分に Java VM の内部を開示する必要があります。

</ul><hr align=left><a name="16465"></a>
<h1> <strong></strong> Java ネイティブインタフェースのアプローチ
</h1>
<a name="16528"></a>
既存のアプローチの1つを標準インタフェースとして適用することを望んでいました。そ
れは、異なる VM の複数のインタフェースを学ぶ必要があるプログラマにかける負荷を最低限にするはずだからです。あいにく、既存の解決策ではこの目標を完全に満足に達成するものは存在しませんでした。
<p><a name="16473"></a>
Netscape の JRI は、移植性のあるネイティブメソッドインタフェースとして想定するものに一番近いものであり、設計の際の開始点としてこれを使用しました。JRI に慣れ親しんだ読者は、API 名前付け規則、メソッドとフィールド ID の使用、ローカルとグローバル参照の使用などの類似性に気付くでしょう。しかし最善の努力に関らず、VM は JRI および JNI の両方をサポートできますが、JNI は JRI とバイナリ互換ではありません。
<p><a name="16835"></a>
Microsoft の RNI は、厳格でないガベージコレクタに取り組むネイティブメソッドの問
題を解決しているため、JDK 1.0 を超えた改善といえます。しかし、RNI は VM 独立ネイティブメソッドインタフェースとしては適当ではありません。JDK のように、RNI ネイティブメソッドは Java オブジェクトに C 構造体としてアクセスします。このため次の 2 つの問題が発生します。
<p><ul><a name="438"></a>
<li>RNI は、内部 Java オブジェクトの配置をネイティブコードに開示する。

<a name="452"></a>
<li>C 構造体として Java オブジェクトに直接アクセスすることによって、高度のガベージコレクションアルゴリズムで必要な「書き込みバリヤ」を効率的に取り込むことができなくなる。

</ul><a name="16838"></a>
バイナリ標準として、COM は異なる VM を超えて完全なバイナリ互換を保証します。COM メソッドの起動には間接的な呼び出しだけが必要で、この呼び出しはほとんどオーバーヘッドを伴いません。さらに、COM オブジェクトはバージョンの問題を解決するダイナミックリンクライブラリに大きな改善をもたらします。 
<p><a name="16815"></a>
しかし、標準 Java ネイティブメソッドインタフェースとしての COM の使用は、次のい
くつかの要因によって妨げられます 
<p><ul><a name="343"></a>
<li>第 1 に、Java/COM インタフェースは private フィールドへのアクセスや一般的な例外の発生などの要求される特定の機能を欠いています。 
<a name="456"></a>
<li>第 2 に、Java/COM インタフェースは自動的に Java オブジェクトに対して標準の IUnknown および IDispatch COM インタフェースを提供し、ネイティブコードが public メソッドとフィールドをアクセスできるようにします。あいにく、IDispatch インタフェースはオーバーロードの Java メソッドを扱わず、メソッド名の照合では大文字小文字を区別します。さらに、IDispatch インタフェースを経由して開示されるすべての Java メソッドは、ダイナミック型チェックと型変換を実行するためにラップされます。これは、IDispatch インタフェースが型チェックがない言語(Basic など)を念頭に設計されているからです。

<a name="344"></a>
<li>第 3 に、個別の低レベル関数を扱う代わりに、COM はソフトウェアコンポーネント(独立したアプリケーションを含む)が一緒に動作するように設計されています。すべての Java クラスまたは低レベルネイティブメソッドをソフトウェアコンポーネントとして扱うことが適当でないと考えます。 

<a name="345"></a>
<li>第 4 に、COM の即座の適用は UNIX プラットフォーム上でサポートを欠いているため妨げられます。

</ul><a name="16519"></a>
Java オブジェクトを COM オブジェクトとしてネイティブコードに開示はしませんが、JNI インタフェース自身は COM とバイナリ互換です。COM が使用するものと同じジャンプテーブル構造体と呼び出し規則を使用します。<em>これは、COM のクロスプラットフォームサポートが使用可能になると直ちに、JNI は Java VM の COM インタフェースになれることを意味します。 
</em><p><a name="16492"></a>
JNI が、与えられた Java VM がサポートする唯一のネイティブメソッドインタフェース
であるべきだとは考えません。標準インタフェースは、ネイティブコードライブラリを異なる Java VM にロードしたいプログラマを支援します。あるケースでは、最高の効率を達成するために、プログラマは低レベルな VM 固有インタフェースを使用する必要があります。他のケースでは、プログラマは高レベルインタフェースを使用し、ソフトウェアコンポーネントを構築するかもしれません。実際、Java 環境とコンポーネントソフトウェア技術が円熟してくるにつれて、ネイティブメソッドはその重要性を徐々に失うことを望んでいます。 
<p><hr align=left><a name="16539"></a>
<h1> JNI のプログラミング
</h1>
<a name="16540"></a>
ネイティブメソッドプログラマは、JNI のプログラミングを開始する必要があります。JNI のプログラミングは、エンドユーザが実行している可能性のあるベンダの VM など未知のものから隔離してくれます。JNI 標準に準拠することで、ネイティブライブラリに対して、与えられたJava VM で実行する最善の機会を与えます。例えば、JDK 1.1 は JDK 1.0 で実装された古い型のネイティブメソッドインタフェースのサポートを継続しますが、JDK の将来バージョンは古い型のネイティブメソッドインタフェースのサポートを止めることは確かです。古い型のインタフェースに依存するネイティブメソッドは書き直す必要があるでしょう。
<p><a name="16546"></a>
Java VM を実装する場合には、JNI も実装する必要があります。Javasoft およびライセ
ンシーは、JNI がオブジェクト表現、ガベージコレクション方式などを含め、VM 実装にオーバーヘッドや制限を課さないように最善の努力をしています。我々が見落とした問題に遭遇した場合には、ご連絡ください。
<p><a name="469"></a>

<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="jniTOC.doc.html">目次</a> | <a href="copyright.doc.html">前項目</a> | <a href="design.doc.html">次項目</a> 

<p>
<font size=-1>Java ネイティブインタフェース仕様 (1997年3月15日にdkramer によって生成されたHTML)<br>
<i><a href="copyright.doc.html">Copyright (C) 1996, 1997 Sun Microsystems, Inc.</a>All rights reserved</i>
<br>
コメントは、<a href="mailto:jni@java.sun.com">jni@java.sun.com</a>宛てに送ってください。
</font>
</body></html>
