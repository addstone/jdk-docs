<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title> </title>
</head>
<body bgcolor=#ffffff>

<table width=600><tr>
<td><a href="jniTOC.doc.html">目次</a> | <a href="intro.doc.html">前項目</a> | <a href="types.doc.html">次項目</a> 
</td><td align=right><i>Java ネイティブインタフェース仕様
</i></td>
</tr></table>
 

<hr><br>
 
<h1><a name="16243"></a>
<strong> 2 - 設計の概要
 </strong></h1>
<hr><p><a name="16648"></a>
本章は JNI の主な設計の問題に焦点をあてています。本項の設計の問題のほとんどはネイティブメソッドと関連があります。呼び出し API については、<a href="invocation.doc.html#15899">第 &#32;5 章、「呼び出し API」</a>に掲載されています。
<p><hr align=left><a name="16696"></a>
<h1> JNI インタフェースの関数とポインタ
</h1>
<a name="16710"></a>
ネイティブコードは、JNI 関数を呼び出して Java VM 機能にアクセスします。JNI 関数は<em>インタフェースポインタ</em>により使用できます。インタフェースポインタは、ポインタを指すポインタです。このポインタはポインタの配列を指し、このそれぞれのポインタがインタフェース関数を指します。どのインタフェース関数も配列内の事前に定義されたオフセットにあります。<a href="design.doc.html#365">図&#32;2-1</a>は、インタフェースポインタの編成を図に示したものです。
<p><a name="362"></a>
<img src="design.doc.anc.gif">
<p>
<a name="365"></a>
<center><h4>Figure 2-1	   インタフェースポインタ 
</h4></center>
<a name="16723"></a>
JNI インタフェースは、C++ 仮想関数テーブルまたは COM インタフェースのように構成されています。固定された組込み関数エントリでなくインタフェーステーブルを使用する利点は、JNI 名前空間がネイティブコードと分れられていることです。VM は複数バージョンの JNI 関数テーブルを容易に提供できます。たとえば、VM は次のように 2つの JNI 関数テーブルをサポートすることもできます。 
<p><ul><a name="17881"></a>
<li>一方のテーブルは、違法な引数の検査を厳密に実行するので、デバッグに適している。

<a name="17882"></a>
<li>他方のテーブルは、JNI 仕様で要求される最小限の検査を実行し、したがって効率があがる。

</ul><a name="1222"></a>
JNI インタフェースポインタは現在のスレッドの中だけで有効です。したがって、ネイティブメソッドは、スレッド間でインタフェースポインタを渡してはなりません。JNI を実装している VM は、JNI インタフェースポインタによって指示された領域にスレッドのローカルデータを割り当て格納することもできます。
<p><a name="678"></a>
ネイティブメソッドは JNI インタフェースポインタを引数として受け取ります。VM が同じ Java スレッドからネイティブメソッドに複数の呼び出しを行うとき、VM はネイティブメソッドの同じポインタに必ずアクセスするよう保証されています。しかし、ネイティブメソッドは、異なる Java スレッドからでも呼び出しできるので、異なる JNI インタフェースポインタを受け取ることもあります。
<p><hr align=left><a name="679"></a>
<h1> ネイティブメソッドのロードとリンク
</h1>
<a name="1232"></a>
ネイティブメソッドは、<code>System.loadLibrary</code>メソッドを用いてロードされます。次の例では、クラス初期化メソッドが、ネイティブメソッド<code>f</code>が中に定義されているプラットフォーム固有のネイティブライブラリをロードしています。
<p><pre>    package pkg; 
    class Cls {
         native double f(int i, String s);
         static {
             System.loadLibrary("pkg_Cls");
         }
    }
</pre><a name="17484"></a>
<code>System.loadLibrary</code> の引数は、プログラマによって任意に選択されたライブラリ名です。このシステムは、標準であるがプラットフォーム固有の方式に従ってライブラリ名をネイティブライブラリ名に変換します。たとえば、Solaris システムは <code>pkg_Cls</code> の名前を <code>libpkg_Cls.so</code> に変換するのに対して、Win32 システムは同じ <code>pkg_Cls</code> の名前を <code>pkg_Cls.dll</code> に変換します。 
<p><a name="17485"></a>
プログラマは、クラスが同じローダでロードできる限り、いくつのクラスが必要とするネイティブメソッドでもすべて単一ライブラリを使用して格納することが可能です。VMはクラスローダごとのロードされたネイティブライブラリのリストを内部的に維持します。ベンダーは、名前が出来るだけぶつからないネイティブライブラリ名を選択すべきです。
<p><a name="17566"></a>
基礎となるオペレーションシステムが動的リンクをサポートしない場合は、すべてのネイティブメソッドが VM と事前にリンク済みでなければなりません。この場合、VM は実際にはこのライブラリをロードすることなく <code>System.loadLibrary</code> 呼び出しを完了します。

<p><a name="16895"></a>
プログラマは JNI 関数 <code>RegisterNatives()</code> を呼び出して、クラスと関連付けられたネイティブメソッドを登録することもできます。<code>RegisterNatives()</code> 関数は、静的リンクされた関数を用いるとき特に有用です。
<p><br><a name="615"></a>
<h2>		 ネイティブメソッド名の解決
</h2>
<a name="16900"></a>
動的リンカはその名前に基づいて項目を解決します。ネイティブメソッド名は、次のコンポーネントを連結して作られます。
<p><ul><a name="16745"></a>
<li>前置詞 <code>Java_
</code>
<a name="16905"></a>
<li>分解された完全修飾クラス名

<a name="16906"></a>
<li>下線("_")セパレータ

<a name="16907"></a>
<li>分解されたメソッド名

<a name="16909"></a>
<li>オーバロードされたネイティブメソッドでは、2個の下線("__")に続いて分解された引数のシグネチャ。

</ul><a name="16908"></a>
VMは、ネイティブライブラリに常駐するメソッドについてメソッド名の一致を調べます。VM は最初ショート名 (すなわち、引数のシグネチャのない名前)を探します。次にロング名 （引数のシグネチャが付いた名前)を探します。プログラマがロング名を使用する必要があるのは、ネイティブメソッドが別のネイティブメソッドによりオーバロードされたときだけです。しかし、ネイティブメソッドが非ネイティブメソッドと同じ名前をもっている場合、これは問題ではありません。非ネイティブメソッド (Javaメソッド) は、ネイティブライブラリに常駐していません。 
<p><a name="612"></a>
次の例では、ネイティブメソッド <code>g</code> はロング名を使ってリンクする必要がありません。他のメソッド <code>g</code> はネイティブメソッドでないため、ネイティブライブラリにないからです。
<p><pre>    class Cls1 {
      int g(int i);
      native int g(double d);
    }
</pre><a name="641"></a>
単純な名前分解スキームを採用して、すべての Unicode 文字が有効な C 関数名に確実に変換されるようにしました。完全修飾クラス名の中でスラッシュ ("/") の代わりに下線 ("_") 文字を使用します。
<strong>名前または型記述子が数字で始まることはないので、<a href="design.doc.html#529">表&#32;2-1</a>の例のように、</strong><code>_0</code><strong>, </strong>...<strong>, 
</strong><code>_9</code><strong>をエスケープシーケンスに使用することができます。
</strong><p><a name="529"></a>
<strong><dl><dd>
<Table Border="0">
<caption><a name="133"></a>
<h4>Table 2-1	 Unicode 文字変換
</h4>
</caption>
<tr><th><a name="668"></a>
エスケープシーケンス

<th><a name="670"></a>
表示 


<tr><td><a name="672"></a>
 <code>_0XXXX
</code>
<td><a name="674"></a>
Unicode 文字<strong> </strong><code>XXXX</code><strong>.
</strong>

<tr><td><a name="676"></a>
<code>_1</code> 

<td><a name="678"></a>
<strong></strong>文字<strong>"_"
</strong>

<tr><td><a name="680"></a>
<code>_2</code> 

<td><a name="682"></a>
シグネチャの中の文字";"


<tr><td><a name="684"></a>
<code>_3</code> 

<td><a name="686"></a>
<strong></strong>シグネチャの中の文字"["



</Table>
</dd></dl>
</strong><p><a name="646"></a>
<strong>ネイティブメソッドとインタフェースAPIの両方とも、所定のプラットフォーム上での標準ライブラリ呼び出し規則に従っています。たとえば、UNIXシステムはC呼び出し規則を使用するのに対して、Win32システムは __stdcallを使用します。
</strong><p><br><a name="715"></a>
<h2>		 ネイティブメソッドの引数
</h2>
<a name="17571"></a>
JNIインタフェースポインタは、ネイティブメソッドの最初の引数です。JNIインタフェースポインタは<var>JNIEnv</var>型です。2番目の引数は、ネイティブメソッドが static であるか nonstatic であるかによって異なります。nonstatic なネイティブメソッドの2番目の引数は、オブジェクトの参照です。static なネイティブメソッドの2番目の引数は、Java クラスの参照です。
<p><a name="739"></a>
残りの引数は、通常の Java メソッド引数に対応しています。ネイティブメソッド呼び出しは、返り値を呼び出しルーチンに渡して戻します。<a href="types.doc.html#15773">第&#32;3章、"JNI の型とデータ構造</a>"で、Java 型とC 型の間のマッピングについて説明しています。 
<p><a name="16748"></a>
<a href="design.doc.html#186">コード&#32;例&#32;2-1</a>には、C 関数を使用してネイティブメソッド <code>f</code> を実装する例があげられています。ネイティブメソッド <code>f</code> は、次のように宣言されます。
<p><pre>    package pkg; 
    class Cls {
         native double f(int i, String s);
         ...
    }
</pre><a name="16755"></a>
長い分解名
<code>Java_pkg_Cls_f_ILjava_lang_String_2</code> をもつ C 関数は、ネイティブメソッド <code>f</code> を実装します。
<p><a name="17883"></a>

<p><a name="186"></a>
<h4>コード例 2-1	 C を使用するネイティブメソッドの実装
</h4>
<pre>    jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
         JNIEnv *env,        /* interface pointer */
         jobject obj,        /* "this" pointer */
         jint i,             /* argument #1 */
         jstring s)          /* argument #2 */
    {
         /* Obtain a C-copy of the Java string */
         const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0);
         /* process the string */
         ...
         /* Now we are done with str */
         (*env)-&gt;ReleaseStringUTFChars(env, s, str);
         return ...
    }
</pre><a name="16770"></a>
常にインタフェースポインタ <var>env</var> を使用して Java オブジェクトを操作していることに注意してください。C++ を使用すると、<a href="design.doc.html#224">コード&#32;例&#32;2-2</a>に示すように、多少すっきりしたバージョンのコードを書くことができます。
<p><a name="17888"></a>

<p><a name="224"></a>
<h4>コード例 2-2	 C++ を使用するネイティブメソッドの実装
</h4>
<pre>    extern "C" /* specify the C calling convention */ 
    jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
         JNIEnv *env,        /* interface pointer */
         jobject obj,        /* "this" pointer */
         jint i,             /* argument #1 */
         jstring s)          /* argument #2 */
    {
         const char *str = env-&gt;GetStringUTFChars(s, 0);
         ...
         env-&gt;ReleaseStringUTFChars(s, str);
         return ...
    }
</pre><a name="16782"></a>
C++ では、余分な間接参照およびインタフェースポインタ引数がソースコードから消えています。しかし、基本的なメカニズムは C による場合とまったく同じです。C++ では、JNI 関数が、その C バージョンまで展開されるインラインメンバ関数として定義されます。

<p><hr align=left><a name="16785"></a>
<h1> Javaオブジェクトの参照
</h1>
<a name="16786"></a>
整数、文字などのプリミティブ型は、Java とネイティブメソッド間でコピーされます。他方、任意の Java オブジェクトは参照渡しです。VM はネイティブコードに渡されたすべてのオブジェクトがガーベッジコレクタによって解放されないよう、これらのオブジェクトを追跡しなければならなりません。ネイティブコードは、逆に、オブジェクトがもう必要ないことを VM に通知する手段をもたなければなりません。さらに、ガーベッジコレクタは、ネイティブコードによって参照されるオブジェクトを移動することもできなければなりません。
<p><br><a name="1242"></a>
<h2>		 グローバルおよびローカル参照
</h2>
<a name="16947"></a>
JNI は、ネイティブコードによって使用されるオブジェクト参照を
<em>ローカル</em> と<em>グローバル参照</em>の2つのカテゴリに分けます。 
ローカル参照は、ネイティブメソッド呼び出しの間のみ有効で、ネイティブメソッドが返されると自動的に解放されます。グローバル参照は、明示的に解放されるまで有効になっています。
<p><a name="16977"></a>
オブジェクトは、ローカル参照としてネイティブメソッドに渡されます。JNI 関数によって返される Java オブジェクトはすべてローカル参照です。JNI では、プログラマがローカル参照からグローバル参照を作成するすることができます。Java オブジェクトを予期する JNI 関数は、グローバルとローカルの両方の参照を受け入れます。ネイティブメソッドは、その結果としてグローバルまたはとローカルのどちらかの参照を VM に返すことになります。
<p><a name="528"></a>
ほとんどの場合、プログラマは、ネイティブメソッドが返した後 VM に基づいてすべてのローカル参照を解放すべきです。しかし、プログラマが明示的にローカル参照を解放する必要がある場合もあります。たとえば、次のような状況があります。
<p><ul><a name="648"></a>
<li>ネイティブメソッドが大きな Java オブジェクトにアクセスし、それによって Java の参照を作成する。次にネイティブメソッドは、呼び出し側に返す前に追加の計算を実行する。大きな Java オブジェクトのローカル参照は、このオブジェクトが残りの計算に使用されなくなった場合でも、ガーベッジコレクトされないようにする。

<a name="650"></a>
<li>ネイティブメソッドは多数のローカル参照を作成しますが、これらのすべてが同時に使用されるわけではない。VM はローカル参照を追跡するため一定量のスペースを必要とし、そのため余り多くのローカル参照を作成すると、システムのメモリがなくなることがある。たとえば、ネイティブメソッドは、大きな配列のオブジェクトを通してループし、その要素をローカル参照として検索し、反復のたびに1つの要素で演算する。各反復の終了後、プログラマはその配列要素のローカル参照をもう必要としない。

</ul><a name="681"></a>
JNI では、プログラマがネイティブメソッド内の任意の点でローカル参照を手操作で削除することができます。プログラマが手操作でローカル参照を解放できるよう保証するため、JNI 関数では、これら関数が結果として返す参照を除いて、余分のローカル参照を作成できないようになっています。
<p><a name="707"></a>
ローカル参照は、これらが作成されたスレッドの中だけで有効です。ネイティブコードは、スレッド間でローカル参照を受渡ししてはなりません。
<p><br><a name="529"></a>
<h2>		 ローカル参照の実装
</h2>
<a name="16789"></a>
ローカル参照子を実装するため、Java VM は Java からネイティブメソッドに制御が遷移するたびレジストリを作成します。レジストリは、移動できないローカル参照を Java オブジェクトにマッピングし、オブジェクトがガーベッジコレクトされないよう守ります。ネイティブメソッドに渡されるすべての Java オブジェクト (JNI 関数呼び出しの結果として返されるものも含む) は、自動的にレジストリに追加されます。このレジストリは、ネイティブメソッドが返った後に削除され、そのすべての項目をガーベッジコレクトできるようにします。 
<p><a name="1272"></a>
レジストリを実装するには、テーブル、連結リスト、またはハッシュテーブルを使用するなど、さまざまの方法があります。レジストリの中の項目の重複を避けるため参照のカウントが使用されることがありますが、JNI の実装では重複項目を検出し壊す必要はありません。
<p><a name="1247"></a>
ローカル参照は、厳格にネイティブスタックをスキャンしても、忠実に実装できません。ネイティブコードは、ローカル参照をグローバルまたはヒープデータ構造に格納することもあります。
<p><hr align=left><a name="1253"></a>
<h1> Javaオブジェクトへのアクセス
</h1>
<a name="945"></a>
JNI は、グローバルおよびローカル参照への豊富なアクセス機能のセットを提供します。これは、VM が内部的にどのようにJavaオブジェクトを表現していても、同じネイティブメソッド実装が作動することを意味します。これが決定的な理由となって、JNI は多様な VM 実装でサポートされています。
<p><a name="940"></a>
<strong>不透明な参照を介してアクセス用関数を使用するオーバヘッドは、Cデータ構造体へ直接アクセスする場合より高くなります。ほとんどの場合に、Javaプログラマがネイティブメソッドを使用してこのインタフェースのオーバヘッドを目立たなくする重いタスクを実行していると考えられます。 
</strong><p><br><a name="1265"></a>
<h2>		 プリミティブ配列へのアクセス
</h2>
<a name="16798"></a>
このオーバヘッドは、整数列や文字列のような多くのプリミティブデータ型を含んでいる大きな Java オブジェクトでは受入れられません。(ベクトルおよび行列の計算を実行するために使用されるネイティブメソッドを考えてください。) Java 配列を反復演算し、各要素をすべて関数呼び出しによって取り出すことは、極めて非効率です。
<p><a name="16799"></a>
ある解決法では、ネイティブメソッドが配列の内容をピン留めするように VM に求めることができるように、「ピン留め」の概念を導入しています。その後ネイティブメソッドは、その要素を指す直接ポインタを受け取ります。しかし、このアプローチは次の 2 つの点を暗黙的に含みます。
<p><ul><a name="17027"></a>
<li>ガーベッジコレクタはピン留めをサポートしなければならない。

<a name="17028"></a>
<li>VM はプリミティブ配列をメモリに切れ目なく連続してレイアウトしなければならない。これはほとんどのプリミティブ配列にとって最も自然な実装ですが、ブール配列はパックでもアンパックでも実装できる。したがって、ブール配列の正確なレイアウトに基づくネイティブコードは移植できない。

</ul><a name="17032"></a>
上述の両方の問題を克服する折衷案を採用しています。
<p><a name="17037"></a>
第1に、Java 配列のセグメントとネイティブメモリバッファの間でプリミティブ配列要素をコピーするための関数のセットを提供します。ネイティブメソッドが大きな配列の中の少数要素だけにアクセスする必要しかない場合は、これらの関数を使用してください。
<p><a name="17038"></a>
第2に、プログラマは別の関数のセットを使用して、ピン留めされたバージョンの配列要素を検索するすることができます。これらの関数は記憶域の割当ておよびコピーを実行するには Java VM が必要なことを覚えておいてください。これらの関数が実際に配列をコピーできるかどうかは、次のように VM の実装によって決まります。
<p><ul><a name="17039"></a>
<li>ガーベッジコレクタがピン留めをサポートする場合、配列のレイアウトはネイティブメソッドが予期するものと同じなので、コピーは必要ない。   

<a name="17040"></a>
<li>それ以外の場合は、配列が移動できないメモリブロック(たとえば、C ヒープの中)にコピーされ、必要なフォーマット変換が実行される。コピーへのポインタが返される。 

</ul><a name="17041"></a>
最後に、このインタフェースは、ネイティブコードがもう配列要素にアクセスする必要がなくなったことを VM に通知するための関数を備えています。これらの関数を呼び出すと、システムは配列のピンを外すか、または元の配列を移動できないコピーと適合させ、そのコピーを解放します。 
<p><a name="740"></a>
このアプローチは、融通性をもたらします。ガーベッジコレクタアルゴリズムにより、指定配列ごとのコピーまたはピン留めについて個別に判断することができます。たとえば、ガーベッジコレクタが小さなオブジェクトをコピーし、大きなオブジェクトをピン留めすることもできます。
<p><a name="743"></a>
JNI の実装では、複数のスレッドで実行されているネイティブメソッドが同時に同じ配列に確実にアクセスできるようにしなければなりません。たとえば、JNI はピン留めされた配列ごとに内部カウンタを備えて、スレッドが別のスレッドもピン留めしている配列のピンを外すことがないようにしています。JNI はネイティブメソッドによる排他アクセスのためにプリミティブ配列をロックする必要がないことに注意してください。異なるスレッドから同時に Java 配列を更新すると、不測の結果を招きます。
<p><br><a name="17074"></a>
<h2>		 フィールドおよびメソッドへのアクセス
</h2>
<a name="781"></a>
JNI では、ネイティブコードでフィールドにアクセスし、Java オブジェクトのメソッドを呼び出すことができます。JNI は、シンボル名および型のシグネチャによってメソッドおよびフィールドを識別します。 2 段ステップのプロセスにより、名前およびシグネチャからフィールドまたはメソッドを探し出すコストを分けています。たとえば、クラス 
<var>cls</var> でメソッド <code>f</code> を呼び出すには、ネイティブコードはまず次のようにメソッド ID を獲得します。
<p><pre>    jmethodID mid = <br>
     env-&gt;GetMethodID(cls, "f", "(ILjava/lang/String;)D");
</pre><a name="17080"></a>
続いてネイティブコードは、次のようにメソッド探索のコストをかけずにメソッド ID を繰り返し使用することができます。
<p><pre>    jdouble result = env-&gt;CallDoubleMethod(obj, mid, 10, str);
</pre><a name="715"></a>
フィールドまたはメソッド ID では、VM がその ID が導き出されたクラスをアンロードしないよう防ぐことはできません。クラスがアンロードされると、フィールドまたはメソッド ID は無効になります。したがって、長期間フィールドまたはメソッド ID を使用するつもりであれば、
ネイティブコードは次のことを確認する必要があります。
<p><ul><a name="735"></a>
<li>基礎クラスの生きている参照を保持するかどうか。

<a name="737"></a>
<li>フィールドまたはメソッド ID を再計算するかどうか。

</ul><a name="738"></a>
<p><a name="739"></a>
JNIは、フィールドまたはメソッド ID がどのように内部的に実装されているかには何の制約も課しません。
<p><hr align=left><a name="17593"></a>
<h1> プログラミングエラーの報告
</h1>
<a name="819"></a>
JNI は、NULL ポインタまたは不正な引数型の受渡しのようなプログラミングエラーについてチェックを行いません。不正な引数型には、Java クラスオブジェクトの代わりに通常の Java オブジェクトを使用するようなことが含まれます。JNI は、次のような理由からこれらの プログラミングエラーについてのチェックを行いません。
<p><ul><a name="822"></a>
<li>JNI 関数に起こり得るすべてのエラー条件についてチェックするよう強制すると、通常の (正常な) ネイティブメソッドのパフォーマンスが低下する。

<a name="825"></a>
<li>多くの場合、このようなチェックを実行できるほど十分な実行時の情報がない。

</ul><a name="17114"></a>
ほとんどの C ライブラリ関数は、プログラムエラーに対して保護されていません。たとえば、
<code>printf()</code> 関数は、無効アドレスを受け取ったとき、通常実行時エラーを起し、エラーコードを返しません。すべての起こり得るエラー条件についてチェックするよう C ライブラリ関数に強制すると、ユーザコードで1回チェックしまたライブラリでも行うように、このようなチェックが重複する結果になる可能性があります。
<p><a name="17594"></a>
プログラマは不正なポインタや間違った型の引数を JNI 関数に渡してはなりません。これを行うと、システム破壊状態または VM のクラッシュを含む、不測の結果に至ることがあります。
<p><hr align=left><a name="770"></a>
<h1> Javaの例外
</h1>
<a name="814"></a>
JNIでは、ネイティブメソッドは任意の Java の例外を発生させることが可能です。ネイティブコードでも、未処理の Java の例外を処理することができます。未処理のままになっている Java の例外は VM に伝達して戻されます。
<p><br><a name="815"></a>
<h2>		 例外とエラーコード
</h2>
<a name="17915"></a>
JNI 関数によっては、Java の例外メカニズムを使用してエラー条件を報告するものもあります。ほとんどの場合、JNI 関数は、エラーコードを返すこと、<em>および</em> Java の例外をスローすることによって、エラー状態を報告します。通常、このエラーコードは、通常の返り値の範囲外にある特殊な返り値 (<code>NULL</code>など) です。したがって、プログラマは以下を行うことができます。
<p><ul><a name="17916"></a>
<li>最後の JNI 呼び出しの返り値を素早くチェックして、エラーが起きているかどうか判断する。

<a name="798"></a>
<li>関数 <code>ExceptionOccurred()</code> を呼び出して、エラー状態のもっと詳細な記述が含まれている例外オブジェクトを取得する。

</ul><a name="776"></a>
プログラマが最初にエラーコードをチェックできない状態で、例外をチェックすることが必要になる場合として、次の2つのケースがあります。
<p><ul><a name="836"></a>
<li>Java メソッドを呼び出す JNI 関数が Java メソッドの結果を返す。プログラマは <code>ExceptionOccurred()</code> を呼び出して、Java メソッドの実行中に起こり得る例外が起きていないかチェックしなければならない。

<a name="17625"></a>
<li> JNI 配列アクセス関数の一部には、エラーコードを返さないが、<code>ArrayIndexOutOfBoundsException</code> または
<code>ArrayStoreException</code> 
をスローするものがある。
</ul><a name="839"></a>
その他すべての場合は、非エラー返り値で、例外がスローされていないことを保証しています。
<p><br><a name="17629"></a>
<h2>		 非同期な例外
</h2>
<a name="17633"></a>
マルチスレッドの場合、現在スレッドではない他のスレッドが非同期な例外をポストすることがあります。非同期な例外は、現在スレッドのネイティブコードの例外に即刻に影響することは、以下の時点までありません。
<p><ul><a name="17681"></a>
<li>ネイティブコードが、同期した例外を発生することができる JNI 関数の1つを呼び出す。

<a name="17934"></a>
<li>ネイティブコードが <code>ExceptionOccurred()</code> を使用して同期的および非同期の例外があるかを明示的にチェックする。

</ul><a name="17935"></a>
同期した例外を発生させる可能性のある JNI 関数だけが非同期な例外をチェックすることに注意してください。
<p><a name="17936"></a>
ネイティブメソッドでは、必要な場所 (他の例外のチェックがない緊密なループの中など) に <code>ExceptionOccurred()</code> のチェックを挿入して、現在のスレッドが非同期な例外に適当な時間の範囲内に応答することを保証する必要があります。
<p><br><a name="17626"></a>
<h2>		 例外の処理
</h2>
<a name="17634"></a>
ネイティブコードで例外を処理するには、次の2通りの方法があります。
<p><ul><a name="17911"></a>
<li>ネイティブメソッドは、すぐに戻るようにして、ネイティブメソッド呼び出しを行った Java コードが例外をスローする立ように選択することができる。
<a name="17912"></a>
<li>ネイティブコードは、<code>ExceptionClear()</code> を呼び出してその例外をクリアしてから、その例外処理コードを実行することもできる。

</ul><a name="17707"></a>
例外の発生後、ネイティブコードは、他の JNI 呼び出しを行う前にまず例外をクリアする必要があります。未処理の例外があるときは、安全に呼び出せる JNI 関数は <code>ExceptionOccurred()</code>、
<code>ExceptionDescribe()</code>、および<code>ExceptionClear()</code>だけです。
<code>ExceptionDescribe()</code>関数は、未処理の例外についてのデバッグメッセージを出力します。
<p><a name="859"></a>

<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="jniTOC.doc.html">目次</a> | <a href="intro.doc.html">前項目</a> | <a href="types.doc.html">次項目</a> 

<p>
<font size=-1>Java ネイティブインタフェース仕様 (1997年3月15日にdkramer によって生成されたHTML)<br>
<i><a href="copyright.doc.html">Copyright (C) 1996, 1997 Sun Microsystems, Inc.</a>All rights reserved</i>
<br>
コメントは、<a href="mailto:jni@java.sun.com">jni@java.sun.com</a>宛てに送ってください。
</font>
</body></html>
